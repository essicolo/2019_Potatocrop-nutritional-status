# Cluster analysis of potato cultivars {#Chapter-Clustering}

## Objective

***
The objective of this chapter is to assign cultivars to groups based on their leaf ionome. Although plant health is a continuous domain rather than a categorical status, yield thresholds are useful for decision-making. Because yield potential varies widely among cultivars, I split experimental data into low- and high-productivity categories using a marketable yield delimiter at the $65^th$ percentile for each cultivar. Hence, I use high yielders subpopulation (samples which marketable yield is larger than the yield cut-off) to perform a cascade k-means clustering aiming to discriminate Groups of similar multivariate compositions (`ionomics groups`). I combine a discriminant analysis to check the  macroelements that best discriminate cultivars. I also check the performence of Groups discrimination by computing the `Groups x clr-coordinates` interaction effect coefficients in a linear mixed effect model. I finally append the new variable `ionomicGroup`to the leaves clr data frame and discard all the rows with any missing data. I map the experimental sites locations in the third sudsection of this chapter. The output data file is called `leaf_ml_df.csv` i.e., the data frame for machine learning chapter (Chapter \@ref(Chapter-Modeling)).

***

## Useful libraries and custom functions

A set of packages is needed for data handling and visualization like the `tidyverse` package presented in previous chapter (Chapter \@ref(Chapter-Data-Processing)), [ellipse](https://rdrr.io/cran/ellipse/) offers functions for drawing ellipses and ellipse-Like confidence regions (maybe I will set this option to FLASE for graph simplicity), [mvoutlier](https://rdrr.io/cran/mvoutlier/) for multivariate outliers detection, [ade4](http://pbil.univ-lyon1.fr/ADE-4) gathers tools for multivariate data analysis (I use it for discriminant analysis), [vegan](https://rdrr.io/cran/vegan/) performs cluster analysis by k-means or cascade k-means clustering, [ggmap](https://github.com/dkahle/ggmap) makes it easy to retrieve raster map tiles from online mapping services like Google Maps and Stamen Maps and plot them using the ggplot2 framework, [extrafont](https://www.r-pkg.org/pkg/extrafont) for custom fonts for graphs with ggplot2, [ggrepel](https://github.com/slowkow/ggrepel) provides text and label geoms for 'ggplot2' that help to avoid overlapping text labels, [nlme](https://www.rdocumentation.org/packages/nlme) for linear and non-linear mixed effect modeling. Some custom functions are also loaded mainly for Pseudo r-square caculation with linear mixed effect model and discriminant biplot.

```{r, warning=FALSE, message=FALSE}
library("tidyverse")
library('ellipse')
library("mvoutlier")
library("ade4")
library("vegan")
library("extrafont")
library("ggrepel")
library("ggmap")
library("nlme")
source("data/functions.R")
source('https://raw.githubusercontent.com/essicolo/AgFun/master/plotDA_trad.R')
```

## Leaves processed compositions data set

For this chapter, the initial data set is the outcome of the previous chapter (Chapter \@ref(Chapter-Data-Processing)) `leaf_clust_df.csv`. I load the data frame and create vectors for useful columns selection.

```{r}
leaf_clust_df <- read_csv("output/leaf_clust_df.csv")
keys_col <- c('NoEssai', 'NoBloc', 'NoTraitement')
clr_no <- c("clr_N", "clr_P", "clr_K", "clr_Mg", "clr_Ca", "clr_Fv")
cultivarAndyield <- c('Cultivar', 'Maturity5', 'RendVendable')
extra_col <- c('LatDD', 'LonDD', 'AnalyseFoliaireStade')
```

The next cell maps experimental sites locations.

```{r leaf_df-sites-locations, out.width = "100%", fig.align = "center", warning = FALSE, message = FALSE, fig.cap = "Location of experimental sites (green dots) in the Québec potato data set."}
qc_leaf <- get_stamenmap(bbox = c(left = -76, right = -68, bottom = 45, top = 50), 
                        zoom = 7, maptype = 'toner-lite')
ggmap(qc_leaf) +
  geom_point(data = leaf_clust_df %>%
               select(LonDD, LatDD) %>%
               unique(), aes(x = LonDD, y = LatDD),
             size = 2, shape = 1) + 
  coord_map("mercator") +
  theme_bw() +
  theme(text = element_text(family = "Arial", face = "bold", size = 12))
#ggsave("images/leaf_clust_df-sites-locations.png", width=10, height=8)
```

## High yielders delimiter

For cluster analysis, I keep only high yielders i.e. yield 65% quantile cutter for each cultivar. The `cutQ` table contains the yield delimiter for each cultivar. Then, this table is used to add the variable `yieldClass` to `leaf_clust_df`. `HY` and `LY` stand for high yield and low yield respectively.

```{r}
cutQ <- leaf_clust_df %>%
  group_by(Cultivar) %>%
  select(RendVendable) %>%
  summarise_if(is.numeric, quantile, probs=0.65, na.rm = TRUE) %>%
  rename(rv_cut = RendVendable)
```

```{r}
leaf_clust_df <- leaf_clust_df %>%
  left_join(cutQ, by = "Cultivar") %>%
  mutate(yieldClass = forcats::fct_relevel(ifelse(RendVendable >= rv_cut, "HY", "LY"), "LY"))
```

For sake of verification, I compute average yield per yieldClass.

```{r, warning=FALSE}
meanYield = leaf_clust_df %>%
    group_by(yieldClass) %>%
    select(RendVendable) %>%
    summarise_if(is.numeric, mean, na.rm = TRUE)
meanYield
```

So, the average marketable yield is 40.48 Mg $ha^-1$ for high yielders and 24.78 Mg $ha^-1$ for low yielders. In comparison, average potato tuber yields in 2017 in Canada and in Québec were respectively 40 Mg $ha^-1$ and 38.4 Mg $ha^-1$.

## Centered log-ratio (clr) centroids computation

Compositional data transformation is done in the loaded file. I keep only clr-transformed coordinates for high yielders, at 10 % blossom (AnalyseFoliaireStade = 10% fleur) in the next chunk.

```{r}
highYielders_df <- leaf_clust_df %>%
  mutate(isNA = apply(.[c(clr_no, cultivarAndyield)], 1, anyNA)) %>%
  mutate(is10pcf = AnalyseFoliaireStade == "10% fleur") %>%
  filter(!isNA & is10pcf & yieldClass == "HY" & NoEssai != "2") %>% 
  select(one_of(keys_col, clr_no, cultivarAndyield)) %>%
  droplevels()
nrow(highYielders_df)
```

So, `r nrow(highYielders_df)` lines of observations (samples) will be used to cluster potato cultivars. I check the number of samples per cultivar in this high yielders data set.

```{r}
percentage <- round(with(highYielders_df, prop.table(table(Cultivar)) * 100), 2)
distribution <- with(highYielders_df, cbind(numHY = table(Cultivar), percentage = percentage))
distribution <- data.frame(cbind(distribution, rownames(distribution)))
colnames(distribution)[3] <- "Cultivar"
distribution$numHY <- as.numeric(as.character(distribution$numHY)) # numHY = number of samples
distribution$percentage <- as.numeric(as.character(distribution$percentage))
distribution %>% arrange(desc(numHY)) %>% head(5) # arrange in descending order
```

```{r, HY-cultivar-abundance, fig.height = 10, fig.width = 5, out.width = "100%", fig.align = "center", warning = FALSE, message = FALSE, fig.cap = "High yielders cultivars abundance.", echo = FALSE}
distribution %>%
  ggplot(aes(x = reorder(Cultivar, numHY), y = numHY)) +
  geom_col() +
  geom_text(aes(label = numHY), hjust = -0.1) +
  ylim(c(0, 250)) +
  labs(x = 'Cultivar', y = 'Number of samples') +
  coord_flip()
```


Some cultivars are well represented, like Superior and Goldrush. Let's compute number of cultivars and trials in the data frame.

```{r}
data.frame(numb_cultivars = n_distinct(highYielders_df$Cultivar, na.rm = TRUE),
           numb_trials = n_distinct(highYielders_df$NoEssai, na.rm = TRUE))
```

I create a table with cultivars, maturity classes and compute median clr values i.e., clr centroids.

```{r}
highYielders_clr <- highYielders_df %>%
  group_by(Cultivar, Maturity5) %>%
  select(Cultivar, Maturity5, starts_with("clr")) %>%
  summarise_all(list(median))
highYielders_clr
```

I use multivariate outliers detection technic to identify outliers with a criterion  of detection limit of 0.975 by cultivar only if cultivars contain at leat 20 rows. If less than 20 rows, all rows are kept. The new data frame will be used for discriminant analysis. I call it `lda_df`.

```{r, warning=FALSE, message=FALSE}
highYielders_df_IO <- highYielders_df %>%
  group_by(Cultivar) %>%
  select(starts_with("clr")) %>%
  do({
    if (nrow(.) < 20) {
      IO = rep(1, nrow(.))
    } else {
      IO = sign1(.[,-1], qcrit=0.975)$wfinal01
    }
    cbind(.,IO)
  })

lda_df <- highYielders_df_IO %>%
              filter(IO == 1) %>%
              droplevels()
nrow(lda_df)
```

So, `r a <- nrow(highYielders_df)-nrow(lda_df); a` outliers have been discarded from the analysis. 

## Axis reduction

Leaves composition data are compositionnal data (non-negative and summing to unity) so are multivariate. As argued by [Legendre et Legendre,  2012](https://www.elsevier.com/books/numerical-ecology/legendre/978-0-444-53868-0) it is not possible to draw such a diagram on paper with more than two or eventually three dimensions, however, even though it is a perfectly valid mathematical construct. For the purpose of analysis, I will project the multidimensional scatter diagram onto bivariate graph which axes are known to be of particular interest. The axes of this graph are chosen to represent a large fraction of the variability of the multidimensional `N-P-K-Mg-Ca-Fv` data matrix, in a space with reduced (i.e. lower) dimensionality relative to the original data set. With the next chunks, I perform a duality diagram (or [dudi](http://pbil.univ-lyon1.fr/ade4/ade4-html/dudi.html)) PCA (priciple component analysis) and store scores and loadings. I also filter the data frame so that cultivars with less than 5 occurences will be masked on the resulting biplot.

```{r}
pca_leaf <- dudi.pca(lda_df[clr_no], scannf = FALSE, scale = FALSE)
lda_leaf <- discrimin(dudi = pca_leaf, fac = factor(lda_df$Cultivar), scannf = FALSE)
lda_leaf_score = lda_leaf$li
lda_leaf_loading = lda_leaf$fa
```

```{r}
lda_df$Cultivar <- factor(lda_df$Cultivar)
lda_leaf_group <- lda_df$Cultivar
n_cultivar <- table(lda_df$Cultivar)
# Do not schow Cultivars whose number of occurrences is < 5
n_filter <- lda_leaf_group %in% names(n_cultivar[n_cultivar >= 5])
filter_cultivars <- names(n_cultivar[n_cultivar >= 5])
lda_df_filter <- lda_df[n_filter, ]
```

I plot the the distance biplot as result of discriminant analysis. I use a custom function.

```{r distance-biplot, fig.height = 6, fig.width = 6, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Discriminant distance biplot of potato cultivars."}
plot_lda(score = lda_leaf_score[n_filter, ],
         loading = lda_leaf_loading[n_filter, ],
         group = lda_leaf_group[n_filter],
         ell_dev = FALSE, 
         ell_err = FALSE, #TRUE, 
         scale_load = 0.5,
         level = 0.95,
         legend = FALSE,
         label = TRUE,
         transparency = 0.3, xlim = c(-2, 2), ylim = c(-3.5, 3),
         points = FALSE)
```

The first discriminant axis (`DS1`) is formed mainly by `Mg`, `K` and `N`. The second discriminant axis (`DS2`) is driven mainly by `Fv`, `K` and weakely `Ca`. The next subsection performs cluster analysis.

## Cascade K Means clustering

What is cascade K Means Clustering? It is an _unsupervised learning algorithm_ inspired by its similar [K Means clustering](https://www.r-bloggers.com/k-means-clustering-in-r/), both trying to cluster data based on their similarity. There is no outcome to be predicted. The algorithm just tries to find patterns in the data. In k means clustering, we have to specify the number of clusters we want the data to be grouped into. In cascade K means method, we give a minimum and a maximum number of cluster wanted. The algorithm randomly assigns each observation to a cluster, and finds the centroid of each cluster. Then, the algorithm iterates through two steps: 

1. reassign data points to the cluster whose centroid is closest,
1. Calculate new centroid of each cluster.

These two steps are repeated till the within cluster variation cannot be reduced any further. The within cluster variation is calculated as the sum of the euclidean distance between the data points and their respective cluster centroids. 

I use the high yielders clr centroids of cultivars in a new data frame which is the same as `highYielders_clr` without maturity classes.The chunk also plots the process results.

```{r clustering, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="K-means partitions comparison (calinski criterion)."}
highYieldersCentroids <- highYielders_df %>%
  group_by(Cultivar) %>%
  select(starts_with("clr")) %>%
  summarise_all(list(median))
set.seed(5773)
highYieldersKmeans <- cascadeKM(highYieldersCentroids[, -1], 
                                inf.gr = 3, sup.gr = 12, criterion = "ssi")
plot(highYieldersKmeans) 
```

The red dot of the right hand side graph shows that `r names(highYieldersKmeans$results[2, ])[which.max(highYieldersKmeans$results[2, ])]` is the optimal clustering partition number. However, their is another optimum at `6 groups`, which is a more manageable number of clusters. The next chunk checks the partitions data frame.

```{r}
highYieldersKmeans$partition %>% head()
```

I consider `6 groups` established from clustering corresponding to the fourth column. I can use the reference of the column or its name `6 groups` directly. I add it up to the centroids data frame.

```{r}
highYieldersCentroids$kgroup <- highYieldersKmeans$partition[, "6 groups"]
```

Then, I compute discriminant scores centroïdes for cultivar and plot cultivar groups in LDA space with a custom function.

```{r}
lda_centroids <- lda_leaf_score %>%
  mutate(group = lda_leaf_group) %>%
  group_by(group) %>%
  summarise_all(list(mean))
```

The plot:

```{r d-biplot-2, fig.height = 6, fig.width = 6, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Discriminant distance biplot of potato cultivars showing ionomics groups."}
plot_lda(score=lda_leaf_score[n_filter, ],
         loading=lda_leaf_loading[n_filter, ],
         group = lda_leaf_group[n_filter],
         ell_dev=FALSE, 
         ell_err= FALSE, #TRUE, 
         scale_load = 0.4,
         level=0.95,
         legend=FALSE,
         label=TRUE,
         transparency=0.4, xlim = c(-2.5, 2), ylim = c(-3, 4),
         points=F)
# colour dots for groups (or clusters)
col = factor(highYieldersCentroids[highYieldersCentroids$Cultivar %in% filter_cultivars, 'kgroup'][[1]])

# remove the cultivar column
points(lda_centroids[lda_centroids$group %in% filter_cultivars, c('DS1', 'DS2')], 
       pch = 19, col = col, cex = 0.9)

legend(1.2, 4, 
       legend = paste(rep('cluster', nlevels(col)), as.numeric(levels(col))), 
       pch = 19, col = unique(col), cex = 0.9)
```

Only 5 clusters are ploted, the third one may be masked because its cultivars has been filtered out. It's a bit difficult to colour cultivar name in the plot with the custom function. I use functions from package `ggrepel` instead. New intermediate data frames are created for this purpose.

```{r}
cultivars_filtre <- data.frame(Cultivar = filter_cultivars, i_group=col)

df <- data.frame(
    score = lda_leaf_score[n_filter, ],
    loadings = lda_leaf_loading[n_filter,],
    Cultivar = lda_leaf_group[n_filter]
                )
df <- df %>% left_join(cultivars_filtre, by="Cultivar")
df %>% head()
```

```{r, warning=FALSE}
centroids = lda_centroids[lda_centroids$group %in% filter_cultivars, ]
names(centroids)[match("group", names(centroids))] <- "Cultivar"
centroids <- centroids %>% left_join(cultivars_filtre, by="Cultivar")
centroids %>% head()
```

The chunk below plots discriminant biplot with colours corresponding to ionomics groups.

```{r gg-biplot, fig.height = 5, fig.width = 10, out.width = "100%", fig.align = "center", warning = FALSE, message = FALSE, fig.cap = "Discriminant biplot and cluster analysis of potato cultivars."}
g <- ggplot(centroids, aes(DS1, DS2, label = Cultivar, col=i_group)) +
  geom_text_repel() +
  geom_point(alpha = 0.5) +
  theme_classic(base_size = 12) +
  theme(axis.text=element_text(size = 12)) +
  theme(text=element_text(family="Arial", face="bold", size = 12))

# Add discriminant loadings using geom_segment() and arrow()
x=0; y=0; labels = c(clr_no, rep(NA, nrow(df)-length(clr_no)))
g + geom_segment(data=df, mapping=aes(x = x, y = y, xend = x+loadings.DS1, yend = y+loadings.DS2), 
                 arrow = arrow(), size = 1, color = "grey80") + 
    geom_text(data = df, mapping = aes(x = loadings.DS1, y = loadings.DS2, label = labels), 
              size = 5, color = "black") +
    geom_hline(yintercept = 0, color = "black", linetype = 2) +
    geom_vline(mapping = aes(xintercept = 0), color = "black", linetype = 2) + 
    theme(axis.line = element_blank())
#ggsave("images/cultivar_clust.png", width=10, height=8, dpi = 300)
```

The next one separate the discriminant biplot in two stackable plots for easy reading.

```{r, grid-plot, fig.height = 5, fig.width = 10, out.width = "100%", fig.align = "center", warning = FALSE, message = FALSE, fig.cap = "Grid plot of discriminant and cluster analyses of potato cultivars."}
g1 <- ggplot(centroids, aes(DS1, DS2, label = Cultivar, colour=i_group)) +
  geom_hline(yintercept=0, color="black", linetype=2) +
  geom_vline(xintercept=0, color="black", linetype=2) + 
  geom_label_repel() +
  geom_point(alpha = 0.5) +
  xlim(c(-3, 3)) +
  ylim(c(-3.5, 6.5)) +
  guides(colour=FALSE) +
  theme_bw(base_size = 12) +
  theme(axis.text=element_text(size=12),
        text=element_text(family="Arial", face="bold", size=12))

g2 <- ggplot() + 
  geom_segment(data=df, mapping=aes(x=x, y=y, xend=x+loadings.DS1, yend=y+loadings.DS2), 
                 size = 1, color="grey50") + 
  geom_label(data=df, mapping=aes(x=loadings.DS1, y=loadings.DS2, label=labels), 
             size=5, color="white", bg = "grey50") +
  geom_hline(yintercept=0, color="black", linetype=2) +
  geom_vline(xintercept=0, color="black", linetype=2) + 
  xlim(c(-3, 3)) +
  ylim(c(-3.5, 6.5)) +
  labs(x = "DS1", y = "DS2") +
  theme_bw(base_size = 12) +
  theme(axis.text=element_text(size = 12),
        text = element_text(family = "Arial", face = "bold", size = 12))
cowplot::plot_grid(g1, g2)
```

I push cultivars yield cut-off (`yieldCutoff`) and ionomics groups (`ionomicGroup`) in the initial data frame.

```{r, warning=FALSE, message=FALSE}
ionomicGroup <- data.frame(lda_centroids[, 1], 
                           ionomicGroup = factor(highYieldersKmeans$partition[, "6 groups"]))
colnames(ionomicGroup)[colnames(ionomicGroup)=="group"] <- "Cultivar"
cutQ <- cutQ[-1, ] # to discard missing cultivar names
colnames(cutQ)[which(names(cutQ) == "rv_cut")] <- "yieldCutoff"
cutQ_ig <- cutQ %>% left_join(ionomicGroup, by = "Cultivar")

leaf_clust_df <- leaf_clust_df %>% 
    left_join(y = cutQ_ig, by = 'Cultivar') %>%
    select(-rv_cut)
```

## Arranging data for Machine Learning 

I select useful columns for the next chapter (Chapter \@ref(Chapter-Modeling)) and save the new table as `dfml.csv`. I conserved only `complete cases`.

```{r}
new_col <- c('yieldCutoff', 'yieldClass', 'ionomicGroup')
dfml <- leaf_clust_df %>%
  select(one_of(c(keys_col, clr_no, cultivarAndyield, new_col, 'AnalyseFoliaireStade'))) %>%
  mutate(isNA = apply(.[c(clr_no, cultivarAndyield)], 1, anyNA)) %>%
  mutate(is10pcf = AnalyseFoliaireStade == "10% fleur") %>%
  filter(!isNA & is10pcf & NoEssai != "2") %>% 
  select(-c(AnalyseFoliaireStade, isNA, is10pcf)) %>%
  droplevels() %>% 
  filter(complete.cases(.))
nrow(dfml)
write_csv(dfml, "output/dfml.csv")
```

So, the Machine learning data table contains `r nrow(dfml)` samples.

## clr x ionomics groups interactions effects

I use a linear mixed effect model to assess the effect of clr coordinates on tubers marketable yield in the ionomics groups. This last subsection perfoms this analysis by extracting and ploting the interaction coefficients of the model.

```{r}
dfml$Cultivar <- factor(dfml$Cultivar)
dfml$NoEssai <- factor(dfml$NoEssai)
colnames(dfml)[colnames(dfml)=="ionomicGroup"] <- "group_i"
dfml$group_i <- factor(dfml$group_i)

clr_no <- c("clr_N", "clr_P", "clr_K", "clr_Ca", "clr_Mg", "clr_Fv")
clrNo <- c("clrN", "clrP", "clrK", "clrCa", "clrMg", "clrFv") # for plot
colnames(dfml)[which(names(dfml) %in% clr_no)] <- clrNo
```

I scale clr coordinates before fitting the linear mixed model. I discard the filling value to deal with singularity problem.

```{r}
dfml.sc <- dfml  # copy
dfml.sc[, clrNo] <- apply(dfml.sc[, clrNo], 2, scale)
used_clr = c("clrN", "clrP", "clrK", "clrCa", "clrMg") # without "clr_Fv"

lmm <- lme(RendVendable ~ (clrN + clrP + clrK + clrCa + clrMg):group_i, 
            data=dfml.sc, 
            random= ~1|NoEssai)

(R2 = rsq(dfml.sc$RendVendable, predict(lmm)))
```

The next code extracts the interactions coefficients of the model and their p-values (pv) matrix.

```{r}
(pv <- summary(lmm)$tTable[-1,])
```

Then, I extract their confident intervals, and process data for the plot.

```{r}
interval <- tibble(Estimate = intervals(lmm)$fixed[-1, 2],
                    LL = intervals(lmm)$fixed[-1, 1], 
                    UL = intervals(lmm)$fixed[-1, 3]) 

interval$variable <- rep('NA', nrow(interval))
interval$variable <- rownames(intervals(lmm)$fixed)[-1]
interval$ionomic_group <- rep(paste("group", 1:nlevels(dfml$group_i)), length(clrNo)-1)
interval$used_clr <- rep(used_clr, each = nlevels(dfml$group_i))

interval$pvalue <- round(pv[,"p-value"], 4)
interval$is_significant = ifelse(interval$pvalue <= 0.05, 'P < 0.05', 'P > 0.05')
interval
```

This cell plots the interaction coefficients and their confident intervals using ggplot2.

```{r coefficients, fig.height = 7, fig.width = 5, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Effect of ionome perturbation on marketable yield as illustrated by a linear mixed effect model."}
gg <- ggplot(data = interval, mapping = aes(x = Estimate, y = used_clr)) + #, color=is_significant)) +
         facet_grid(ionomic_group ~ .) + 
         geom_vline(xintercept = 0, lty = 2) +
         geom_segment(mapping = aes(x = LL, xend = UL, y = used_clr, yend = used_clr)) +
         geom_point() +
         labs(x = "Coefficient", y = "") +
         theme_bw() +
         theme(text = element_text(family = "Arial", face = "bold", size = 12))
gg + theme(legend.title = element_blank())
#ggsave("images/coef_lmm.tiff", width = 5, height = 7, dpi = 300)
```


