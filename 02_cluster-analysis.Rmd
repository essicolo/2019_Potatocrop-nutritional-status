# Cluster analysis of potato cultivars {#Chapter-Clustering}

## Objective

***
Although plant health is a continuous domain rather than a categorical status, yield thresholds are useful for decision-making. Because yield potential varies widely among cultivars, I use this chapter to split experimental data into low- and high-productivity categories using a marketable yield delimiter at the 65th percentile for each cultivar. Hence, I use high yielders subpopulation (samples which marketable yield is larger than the yield cut-off) to perform a cascade k-means clustering aiming to discriminate Groups of similar multivariate compositions (`ionomics groups`). I combine a discriminant analysis to check the macroelements that best discriminate cultivars. I also check the performence of Groups discrimination by computing the `Groups X clr-coordinates` interaction effect coefficients in a linear mixed effect model. I finally append the new variable `ionomicGroup`to the leaves clr data frame and discard all the rows with any missing data. I map the experimental sites locations in the third sudsection of this chapter. The output data file is called `leaf_ml_df.csv` i.e., the data frame for machine learning chapter \@ref(Chapter-Modeling).
***

## Useful libraries and custom functions

We need a set of packages for data handling and visualization like the `tidyverse` package presented in previous chapter \@ref(Chapter-Data-Processing), [ellipse](https://rdrr.io/cran/ellipse/) offers functions for drawing ellipses and ellipse-Like confidence regions (maybe I will set this option to FLASE for graph simplicity), [mvoutlier](https://rdrr.io/cran/mvoutlier/) for multivariate outliers detection, [ade4](http://pbil.univ-lyon1.fr/ADE-4) gathers tools for multivariate data analysis (I use it for discriminant analysis), [vegan](https://rdrr.io/cran/vegan/) performs cluster analysis by k-means or cascade k-means clustering, [ggmap](https://github.com/dkahle/ggmap) makes it easy to retrieve raster map tiles from online mapping services like Google Maps and Stamen Maps and plot them using the ggplot2 framework, [extrafont](https://www.r-pkg.org/pkg/extrafont) for custom fonts for graphs with ggplot2, [ggrepel](https://github.com/slowkow/ggrepel) provides text and label geoms for 'ggplot2' that help to avoid overlapping text labels, [plotly](https://plotly-r.com) ..., [nlme](https://www.rdocumentation.org/packages/nlme) for linear and non-linear mixed effect modeling. Some custom functions are also loaded mainly for Pseudo r-square caculation with linear mixed effect model and discriminant biplot.

```{r, warning=FALSE, message=FALSE}
library("tidyverse")
library('ellipse')
library("mvoutlier")
library("ade4")
library("vegan")
library("extrafont")
library("ggrepel")
library("ggmap")
#library("plotly")
library("nlme")
source("data/functions.R")
source('https://raw.githubusercontent.com/essicolo/AgFun/master/plotDA_trad.R')
```

## Leaves processed compositions data set

For this chapter, the initial data set is the outcome of the prvious chapter (\@ref(Chapter-Data-Processing)) `leaf_clust_df`. I load the data frame and create vectors of columns I will use in this chapter.

```{r}
leaf_clust_df <- read_csv("output/leaf_clust_df.csv")
keys_col <- c('NoEssai', 'NoBloc', 'NoTraitement')
clr_no <- c("clr_N", "clr_P", "clr_K", "clr_Mg", "clr_Ca", "clr_Fv")
cultivarAndyield <- c('Cultivar', 'Maturity5', 'RendVendable')
extra_col <- c('LatDD', 'LonDD', 'AnalyseFoliaireStade')
```

The next cell maps experimental sites locations.

```{r leaf_df-sites-locations, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Location of experimental sites (green dots) in the Québec potato data set."}
#library("ggmap")
qc_leaf <- get_stamenmap(bbox = c(left=-76, right=-68, bottom=45, top=50), 
                        zoom=7, maptype = 'toner-lite')
ggmap(qc_leaf) +
  geom_point(data = leaf_clust_df %>%
               select(LonDD, LatDD) %>%
               unique(), aes(x = LonDD, y = LatDD),
             size = 2, shape = 1) + 
  coord_map("mercator") +
  theme_bw() +
  theme(text = element_text(family = "Arial", face = "bold", size = 12))
#ggsave("images/leaf_clust_df-sites-locations.png", width=10, height=8)
```

## High yielders delimiter

For cluster analysis, I keep only high yielders i.e. yield 65% quantile cutter for each cultivar. The `cutQ` table contains the yield delimiter for each cultivar. Then, this table is used to add the variable `yieldClass` to `leaf_clust_df`. `HY` and `LY` stand for high yield and low yield respectively.

```{r}
cutQ <- leaf_clust_df %>%
  group_by(Cultivar) %>%
  select(RendVendable) %>%
  summarise_if(is.numeric, quantile, probs=0.65, na.rm = TRUE) %>%
  rename(rv_cut = RendVendable)
leaf_clust_df <- leaf_clust_df %>%
  left_join(cutQ, by = "Cultivar") %>%
  mutate(yieldClass = fct_relevel(ifelse(RendVendable >= rv_cut, "HY", "LY"), "LY"))
```

For sake of verification, I compute average yield per yieldClass.

```{r, warning=FALSE}
meanYield = leaf_clust_df %>%
    group_by(yieldClass) %>%
    select(RendVendable) %>%
    summarise_if(is.numeric, mean, na.rm = TRUE)
meanYield
```

Average marketable yield is 40.48 Mg ha-1 for high yielders and 24.78 Mg ha^-1 for low yielders. In comparison, average potato tuber yields in 2017 in Canada and in Québec were respectively 40 Mg ha^-1 and 38.4 Mg ha^-1.

## `clr` centroids computation

Compositional data transformation is done in the loaded file. I keep only clr-transformed coordinates for high yielders, at 10 % blossom (AnalyseFoliaireStade = 10% fleur) in the next chunk.

```{r}
highYielders_df <- leaf_clust_df %>%
  mutate(isNA = apply(.[c(clr_no, cultivarAndyield)], 1, anyNA)) %>%
  mutate(is10pcf = AnalyseFoliaireStade == "10% fleur") %>%
  filter(!isNA & is10pcf & yieldClass == "HY" & NoEssai != "2") %>% 
  select(one_of(keys_col, clr_no, cultivarAndyield)) %>%
  droplevels()
nrow(highYielders_df)
```

So, `r nrow(highYielders_df)` lines of observations (samples) will be used for potato cultivars clustering. I Check how many rows of data are they for each cultivar.

```{r}
percentage <- round(with(highYielders_df, prop.table(table(Cultivar)) * 100), 2)
distribution <- with(highYielders_df, cbind(numHY = table(Cultivar), percentage = percentage))
distribution <- data.frame(cbind(distribution, rownames(distribution)))
colnames(distribution)[3] <- "Cultivar"
distribution$numHY <- as.numeric(as.character(distribution$numHY)) # numHY = number of samples
distribution$percentage <- as.numeric(as.character(distribution$percentage))
distribution %>% arrange(desc(numHY)) %>% head(5) # arrange in descending order
```

Some cultivars are well represented, like Superior and Goldrush. Let's compute number of cultivars and trials in the data frame.

```{r}
data.frame(numb_cultivars = n_distinct(highYielders_df$Cultivar, na.rm = TRUE),
           numb_trials = n_distinct(highYielders_df$NoEssai, na.rm = TRUE))
```

I create a table with cultivars, maturity classes and computed median clr values i.e., clr centroids.

```{r}
highYielders_clr <- highYielders_df %>%
  group_by(Cultivar, Maturity5) %>%
  select(Cultivar, Maturity5, starts_with("clr")) %>%
  summarise_all(list(median))
highYielders_clr
```

I use multivariate outliers detection technic to identify outliers with a criterion  of detection limit of 0.975 by cultivar only if cultivars contain at leat 20 rows. If less than 20 rows, all rows are kept. The new data frame will be used for discriminant analysis. I call it `lda_df`.

```{r, warning=FALSE, message=FALSE}
highYielders_df_IO <- highYielders_df %>%
  group_by(Cultivar) %>%
  select(starts_with("clr")) %>%
  do({
    if (nrow(.) < 20) {
      IO = rep(1, nrow(.))
    } else {
      IO = sign1(.[,-1], qcrit=0.975)$wfinal01
    }
    cbind(.,IO)
  })

lda_df <- highYielders_df_IO %>%
              filter(IO == 1) %>%
              droplevels()
nrow(lda_df)
```

Hence, `r nrow(highYielders_df)-nrow(lda_df)` outliers have been discarded from the analysis. The remaining data frame contains `r n_distinct(lda_df$Cultivar, na.rm = TRUE)` cultivars from `r n_distinct(lda_df$NoEssai, na.rm = TRUE)` trials.

## Axis reduction

Leaves composition data are compositionnal data (non-negative and summing to unity) so are multivariate. As argued by [Legendre et Legendre,  2012](https://www.elsevier.com/books/numerical-ecology/legendre/978-0-444-53868-0) It is not possible to draw such a diagram on paper with more than two or eventually three dimensions, however, even though it is a perfectly valid mathematical construct. For the purpose of analysis, I will project the multidimensional scatter diagram onto bivariate graphs whose axes are known to be of particular interest. The axes of these graphs are chosen to represent a large fraction of the variability of the multidimensional `N-P-K-Mg-Ca-Fv` data matrix, in a space with reduced (i.e. lower) dimensionality relative to the original data set. With the next chunks, I perform a duality diagram (or [dudi](http://pbil.univ-lyon1.fr/ade4/ade4-html/dudi.html)) PCA (priciple component analysis) and store scores and loadings. I also filter the data frame so that cultivars with less than 5 occurences will be masked on the resulting biplot.

```{r}
pca_leaf <- dudi.pca(lda_df[clr_no], scannf = FALSE, scale = FALSE)
lda_leaf <- discrimin(dudi = pca_leaf, fac = factor(lda_df$Cultivar), scannf = FALSE)
lda_leaf_score = lda_leaf$li
lda_leaf_loading = lda_leaf$fa
```

```{r}
lda_df$Cultivar <- factor(lda_df$Cultivar)
lda_leaf_group <- lda_df$Cultivar
n_cultivar <- table(lda_df$Cultivar)
# Do not schow Cultivars whose number of occurrences is < 5
n_filter <- lda_leaf_group %in% names(n_cultivar[n_cultivar >= 5])
filter_cultivars <- names(n_cultivar[n_cultivar >= 5])
lda_df_filter <- lda_df[n_filter, ]
```

I can plot the tThe distance biplot as result of discriminant analysis. I use a custom function.

```{r distance-biplot, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Discriminant distance biplot of potato cultivars."}
options(repr.plot.width = 6, repr.plot.height = 6)
plot_lda(score = lda_leaf_score[n_filter, ],
         loading = lda_leaf_loading[n_filter, ],
         group = lda_leaf_group[n_filter],
         ell_dev = FALSE, 
         ell_err = FALSE, #TRUE, 
         scale_load = 0.5,
         level = 0.95,
         legend = FALSE,
         label = TRUE,
         transparency = 0.3, xlim = c(-2, 2), ylim = c(-3.5, 3),
         points = FALSE)
```

The first discriminant axis (`DS1`) is formed mainly by Mg, K and N. The second discriminant axis (`DS2`) is driven mainly by the Fv, K and weakely by Ca. I perform cluster analysis in next subsection.

## Cascade K Means clustering

What is cascade K Means Clustering? It is an an unsupervised learning algorithm inspired by its similar [K Means clustering](https://www.r-bloggers.com/k-means-clustering-in-r/) both trying to cluster data based on their similarity. There is no outcome to be predicted. The algorithm just tries to find patterns in the data. In k means clustering, we have to specify the number of clusters we want the data to be grouped into. In cascade K means method, we give a minimum and a maximum number of cluster wanted. The algorithm randomly assigns each observation to a cluster, and finds the centroid of each cluster. Then, the algorithm iterates through two steps: 

1. reassign data points to the cluster whose centroid is closest,
1. Calculate new centroid of each cluster.

These two steps are repeated till the within cluster variation cannot be reduced any further. The within cluster variation is calculated as the sum of the euclidean distance between the data points and their respective cluster centroids. 

I use the high yielders clr centroids for cultivars in a next data frame which is the same as `highYielders_clr` without maturity classes, and `Calinski-Harabasz (1974) criterion (package vegan)` for clustering.

```{r, message=FALSE}
highYieldersCentroids <- highYielders_df %>%
  group_by(Cultivar) %>%
  select(starts_with("clr")) %>%
  summarise_all(list(median))
set.seed(194474)
highYieldersKmeans <- cascadeKM(highYieldersCentroids[, -1], 
                                inf.gr = 2, sup.gr = 8, criterion = "ssi")
```

The next chunk plots the process results.

```{r clustering, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="K-means partitions comparison (calinski criterion)."}
options(repr.plot.width = 6, repr.plot.height = 4)
plot(highYieldersKmeans) 
```

The red dot of the right hand side graph shows 4 optimal clustering partitions. Check the differnt partitions data frame.

```{r}
highYieldersKmeans$partition %>% head()
```

Consider `4 groups` from clustering according to `calinski criterion`, this corresponds to the column 2 or use **4 groups** as column name directly, and add it up to the previous data frame.

```{r}
highYieldersCentroids$kgroup <- highYieldersKmeans$partition[, "4 groups"]
```

I compute discriminant scores centroïdes for cultivars.

```{r}
lda_centroids <- lda_leaf_score %>%
  mutate(group = lda_leaf_group) %>%
  group_by(group) %>%
  summarise_all(list(mean))
```

Plot Cultivar groups in LDA with a custom function.

```{r d-biplot-2, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Discriminant distance biplot of potato cultivars showing ionomics groups."}
options(repr.plot.width = 6, repr.plot.height = 6)
plot_lda(score=lda_fol_score[n_filter, ],
         loading=lda_fol_loading[n_filter, ],
         group = lda_fol_group[n_filter],
         ell_dev=FALSE, 
         ell_err= FALSE, #TRUE, 
         scale_load = 0.4,
         level=0.95,
         legend=FALSE,
         label=TRUE,
         transparency=0.4, xlim = c(-2.5, 2), ylim = c(-3.5, 3.5),
         points=F)
# colour dots for groups (or clusters)
col = factor(highYieldersCentroids[highYieldersCentroids$Cultivar %in% filter_cultivars, 'kgroup'][[1]])

# remove the cultivar column
points(lda_centroids[lda_centroids$group %in% filter_cultivars, c('DS1', 'DS2')], 
       pch = 19, col = col, cex = 0.9)

legend(-2.5, 3, 
       legend = paste(rep('cluster', nlevels(col)), as.numeric(levels(col))), 
       pch = 19, col = unique(col), cex = 0.9)
```

It's a bit difficult to colour cultivar names in the plot with the custom function. I use functions from packages `ggplot2`, `ggrepel` and `plotly` instead. The package `ggplot2` is already loaded with `tidyverse`. New data frames are created with useful variables.

```{r}
cultivars_filtre <- data.frame(Cultivar = filter_cultivars, i_group=col)

df <- data.frame(
    score = lda_leaf_score[n_filter, ],
    loadings = lda_leaf_loading[n_filter,],
    Cultivar = lda_leaf_group[n_filter]
                )
df <- df %>% left_join(cultivars_filtre, by="Cultivar")
df %>% head()
```

```{r, warning=FALSE}
centroids = lda_centroids[lda_centroids$group %in% filter_cultivars, ]
names(centroids)[match("group", names(centroids))] <- "Cultivar"
centroids <- centroids %>% left_join(cultivars_filtre, by="Cultivar")
centroids %>% head()
```

The chunk below plots discriminant biplot with colours corresponding to ionomics groups.

```{r gg-biplot, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Discriminant biplot and cluster analysis result of potato cultivars."}
options(repr.plot.width = 9, repr.plot.height = 9)
g <- ggplot(centroids, aes(DS1, DS2, label = Cultivar, col=i_group)) +
  geom_text_repel() +
  geom_point(alpha = 0.5) +
  theme_classic(base_size = 12) +
  scale_color_manual(values=c("red", "magenta", "blue", "black")) + 
  theme(axis.text=element_text(size=12)) +
  theme(text=element_text(family="Arial", face="bold", size=12))

# Add discriminant loadings using geom_segment() and arrow()
x=0; y=0; labels = c(clr_no, rep(NA, nrow(df)-length(clr_no)))
g + geom_segment(data=df, mapping=aes(x=x, y=y, xend=x+loadings.DS1, yend=y+loadings.DS2), 
                 arrow=arrow(), size = 1, color="grey80") + 
    geom_text(data=df, mapping=aes(x=loadings.DS1, y=loadings.DS2, label=labels), 
              size=5, color="black") +
    geom_hline(yintercept=0, color="black", linetype=2) +
    geom_vline(mapping=aes(xintercept=0), color="black", linetype=2) + 
    theme(axis.line=element_blank())
#ggsave("images/cultivar_clust.png", width=10, height=8, dpi = 300)
```

I push cultivars yield cut-off and ionomics groups in initial data frame.

```{r, warning=FALSE, message=FALSE}
ionomicGroup <- data.frame(lda_centroids[, 1], 
                           ionomicGroup = factor(highYieldersKmeans$partition[, "4 groups"]))
colnames(ionomicGroup)[colnames(ionomicGroup)=="group"] <- "Cultivar"
cutQ <- cutQ[-1, ] # to discard missing cultivar names
colnames(cutQ)[which(names(cutQ) == "rv_cut")] <- "yieldCutoff"
cutQ_ig <- cutQ %>% left_join(ionomicGroup, by = "Cultivar")

leaf_df <- leaf_df %>% 
    left_join(y = cutQ_ig, by = 'Cultivar') %>%
    select(-rv_cut)
```

Processing data for Machine Learning `dfml`, saved as `data_ionome.csv`. Exctract usefull columns from `fol_df`. Conserve only `complete cases. Backup

```{r}
dfml <- leaf_df %>%
  mutate(isNA = apply(.[c(clr_no, cultivarAndyield)], 1, anyNA)) %>%
  mutate(is10pcf = AnalyseFoliaireStade == "10% fleur") %>%
  filter(!isNA & is10pcf & NoEssai != "2") %>% 
  select(one_of(c(keys_col, clr_no, cultivarAndyield, 'yieldClass', 'ionomicGroup'))) %>%
  select(-AnalyseFoliaireStade) %>%
  droplevels() %>% 
  filter(complete.cases(.))
nrow(dfml)
write_csv(dfml, "output/leaf_ml_df.csv")
```

## clr and ionomics groups interactions effects

Linear mixed effect modeling of yield relative to the `ionome*ionomicGroup` interaction (extraction of the interactions coefficients).

```{r}
dfml$Cultivar <- factor(dfml$Cultivar)
dfml$Maturity5 <- relevel(dfml$Maturity5, ref="late")
dfml$Cultivar <- relevel(dfml$Cultivar, ref="Goldrush")
dfml$NoEssai <- factor(dfml$NoEssai)
colnames(dfml)[colnames(dfml)=="ionomicGroup"] <- "group_i"
dfml$group_i <- factor(dfml$group_i)

clr_no <- c("clr_N", "clr_P", "clr_K", "clr_Ca", "clr_Mg", "clr_Fv")
clrNo <- c("clrN", "clrP", "clrK", "clrCa", "clrMg", "clrFv") # for plot
colnames(dfml)[which(names(dfml) %in% clr_no)] <- clrNo
```

I scale clr coordinates before ajusting linear mixed model. Discard the filling value to deal with singularity problem.

```{r}
dfml.sc <- dfml  # copy
dfml.sc[, clrNo] <- apply(dfml.sc[, clrNo], 2, scale)
used_clr = c("clrN", "clrP", "clrK", "clrCa", "clrMg") # without "clr_Fv"

lmm <- lme(RendVendable ~ (clrN + clrP + clrK + clrCa + clrMg):group_i, 
            data=dfml.sc, 
            random= ~1|NoEssai)

pseudoR2 = rsq(dfml.sc$RendVendable, predict(lmm))
pseudoR2
```

The next code extracts the interactions coefficients of the model and their p-values (pv) matrix.

```{r}
pv <- summary(lmm)$tTable[-1,]
pv
```

Then, I extract their confident intervals, and process data for the plot.

```{r}
interval <- tibble(Estimate = intervals(lmm)$fixed[-1, 2],
                    LL = intervals(lmm)$fixed[-1, 1], 
                    UL = intervals(lmm)$fixed[-1, 3]) 

interval$variable <- rep('NA', nrow(interval))
interval$variable <- rownames(intervals(lmm)$fixed)[-1]
interval$ionomic_group <- rep(paste("group", 1:nlevels(dfml$group_i)), length(clrNo)-1)
interval$used_clr <- rep(used_clr, each = nlevels(dfml$group_i))

interval$pvalue <- pv[,"p-value"]
interval$is_significant = ifelse(interval$pvalue <= 0.05,
                                      'P < 0.05',
                                      'P > 0.05')
interval
```

This cell plots the interaction coefficients and their confident intervals using ggplot2.

```{r coefficients, out.width="100%", fig.align="center", warning=FALSE, message=FALSE, fig.cap="Effect of ionome perturbation on marketable yield as illustrated by a linear mixed effect model."}
options(repr.plot.width = 5, repr.plot.height = 5)
gg <- ggplot(data = interval, mapping = aes(x = Estimate, y = used_clr, color=is_significant)) +
         facet_grid(ionomic_group ~ .) + #, scales = 'free', space = 'free') +
         geom_vline(xintercept = 0, lty = 2) +
         geom_segment(mapping = aes(x = LL, xend = UL, y = used_clr, yend = used_clr)) +
         geom_point() +
         labs(x = "Coefficient", y = "") +
         theme_bw() +
         theme(text=element_text(family="Arial", face="bold", size=12))
gg + theme(legend.title = element_blank())#, legend.position = 'bottom')
#ggsave("images/coef_lmm.tiff", width = 5, height = 5, dpi = 300)
```


