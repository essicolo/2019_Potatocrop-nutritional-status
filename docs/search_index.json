[
["Chapter-Perturbation.html", "Chapter 4 Ionome perturbation concept 4.1 Objective 4.2 Data set and useful libraries 4.3 Euclidean distance from nutritionally balanced compositions 4.4 Perturbation effect of some elements on the whole 4.5 Rebalancing a misbalanced sample by perturbation", " Chapter 4 Ionome perturbation concept 4.1 Objective The objective of this chapter is to show the user a visual example of perturbation effect in a Simplex, and to develop a mathematical workflow useful to adjust the ionome of potato crops for diagnostic purpose. Perturbation in compositional space plays the same role as translation plays in real space. The assumption is that some natural processes in nature can be interpreted as a change from one composition C1 to another C2 through the application of a perturbation: p ⊕ C1 ===&gt; C2. The difference between a new observation and a closest healthy composition (closest true negative - TN) or reference composition can be back-transformed to the compositional space. The resulted vector is the perturbation vector. Theoretically, a misbalanced composition could be balanced (translated into a healthy zone) using a perturbation operation. Using this concept, ionome of a new cultivar could be assigned to the cultivar sharing similar leaf composition, and where nutrient requirements have been already documented by fertilizer trials. We used the testing set to display the effect of a perturbation on the whole simplex. We selected two elements (N and P) and simulated an increase of their initial (observed) clr values by 20% (theoretically). The observed (observation) and new clr vector (perturbation) were back transformed to N, P, K, Ca, Mg and Fv compositional space for comparison. Secondly, the procedure used to rebalance a misbalanced composition is decribed. As explained at the end of the Chapter 3, we consider as True Negatives (TN) specimens (or healthy points) for this study, observations of the training set having a high yield (HY) and correctly predicted by the k nearest neighbors model. 4.2 Data set and useful libraries We need package compositions for further clr back-transformation to compositional space. The package reshape will be used to melt an intermediate data frame. library(&quot;tidyverse&quot;) library(&quot;extrafont&quot;) library(&#39;compositions&#39;) library(&quot;reshape&quot;) The previous train_df and test_df are loaded. train_df = read_csv(&quot;output/train_df.csv&quot;) ## Parsed with column specification: ## cols( ## NoEssai = col_double(), ## NoBloc = col_double(), ## NoTraitement = col_double(), ## clr_N = col_double(), ## clr_P = col_double(), ## clr_K = col_double(), ## clr_Ca = col_double(), ## clr_Mg = col_double(), ## clr_Fv = col_double(), ## RendVendable = col_double(), ## rv_cut = col_double(), ## yieldClass = col_character(), ## Maturity5 = col_character(), ## Cultivar = col_character(), ## pred_yield = col_character() ## ) test_df = read_csv(&quot;output/test_df.csv&quot;) ## Parsed with column specification: ## cols( ## NoEssai = col_double(), ## NoBloc = col_double(), ## NoTraitement = col_double(), ## clr_N = col_double(), ## clr_P = col_double(), ## clr_K = col_double(), ## clr_Ca = col_double(), ## clr_Mg = col_double(), ## clr_Fv = col_double(), ## RendVendable = col_double(), ## rv_cut = col_double(), ## yieldClass = col_character(), ## Maturity5 = col_character(), ## Cultivar = col_character(), ## pred_yield = col_character() ## ) TNs = train_df %&gt;% filter(yieldClass == &#39;HY&#39; &amp; pred_yield == &#39;HY&#39;) clr_no = c(&quot;clr_N&quot;, &quot;clr_P&quot;, &quot;clr_K&quot;, &quot;clr_Ca&quot;, &quot;clr_Mg&quot;, &quot;clr_Fv&quot;) Filtrer train_df et test_df pour ne conserver que les observations ayant les cultivars correspondant dans les vrais négatifs, et seulement les déséquilibrés. train_df &lt;- train_df %&gt;% filter(Cultivar %in% unique(TNs$Cultivar)) test_df &lt;- test_df %&gt;% filter(Cultivar %in% unique(TNs$Cultivar)) 4.3 Euclidean distance from nutritionally balanced compositions The chunk below activates the custom function used to compute Euclidean distance. eucl_dist_f &lt;- function(x, y) { sqrt(sum((x-y)^2)) } For each imbalanced composition, we use the next loop to compute all the euclidean distances between all the compositions in “TNs” of the corresponding cultivar. The computation is possible even if the cultivar is unknown, the loop must just be updated. Here, the loop returns the smallest Euclidean distance stored in debal vector. For train_df: debal &lt;- c() debal_index &lt;- c() for (i in 1:nrow(train_df)) { clr_i &lt;- as.numeric(train_df[i, clr_no]) TNs_target &lt;- TNs %&gt;% filter(Cultivar == train_df$Cultivar[i]) %&gt;% select(clr_no) eucl_dist &lt;- apply(TNs_target, 1, function(x) eucl_dist_f(x = x, y = clr_i)) debal_index[i] &lt;- which.min(eucl_dist) debal[i] &lt;- eucl_dist[debal_index[i]] } train_df$debal &lt;- debal train_df &lt;- train_df %&gt;% filter(debal != 0) train_df %&gt;% glimpse() ## Observations: 1,724 ## Variables: 16 ## $ NoEssai &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4... ## $ NoBloc &lt;dbl&gt; 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 3, 3... ## $ NoTraitement &lt;dbl&gt; 1, 2, 3, 6, 1, 2, 8, 4, 5, 7, 1, 1, 2, 3, 4, 2, 3... ## $ clr_N &lt;dbl&gt; 0.3321186, 0.4252302, 0.4453417, 0.4885647, 0.473... ## $ clr_P &lt;dbl&gt; -2.518325, -2.394957, -2.365429, -2.525335, -2.28... ## $ clr_K &lt;dbl&gt; 0.8379383, 1.1387291, 1.0112272, 0.9418880, 0.718... ## $ clr_Ca &lt;dbl&gt; -0.4794688, -0.5154924, -0.7290838, -0.6426036, -... ## $ clr_Mg &lt;dbl&gt; -1.639076, -2.346167, -1.990736, -1.763195, -1.69... ## $ clr_Fv &lt;dbl&gt; 3.466813, 3.692658, 3.628680, 3.500681, 3.337752,... ## $ RendVendable &lt;dbl&gt; 18.944200, 40.351800, 33.037900, 41.016700, 15.11... ## $ rv_cut &lt;dbl&gt; 41.33053, 41.33053, 41.33053, 41.33053, 41.33053,... ## $ yieldClass &lt;chr&gt; &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;... ## $ Maturity5 &lt;chr&gt; &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-se... ## $ Cultivar &lt;chr&gt; &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;... ## $ pred_yield &lt;chr&gt; &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;... ## $ debal &lt;dbl&gt; 0.4859422, 0.3245021, 0.2126167, 0.2987338, 0.384... For test_df: debal &lt;- c() debal_index &lt;- c() for (i in 1:nrow(test_df)) { clr_i &lt;- as.numeric(test_df[i, clr_no]) TNs_target &lt;- TNs %&gt;% filter(Cultivar == test_df$Cultivar[i]) %&gt;% select(clr_no) eucl_dist &lt;- apply(TNs_target, 1, function(x) eucl_dist_f(x = x, y = clr_i)) debal_index[i] &lt;- which.min(eucl_dist) debal[i] &lt;- eucl_dist[debal_index[i]] } test_df$debal &lt;- debal test_df &lt;- test_df %&gt;% filter(debal != 0) test_df %&gt;% glimpse() ## Observations: 803 ## Variables: 16 ## $ NoEssai &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 5, 5, 5, 5... ## $ NoBloc &lt;dbl&gt; 1, 1, 2, 2, 2, 3, 3, 3, 1, 1, 1, 1, 3, 1, 1, 1, 2... ## $ NoTraitement &lt;dbl&gt; 4, 5, 5, 6, 7, 1, 2, 8, 2, 3, 5, 6, 1, 2, 4, 5, 5... ## $ clr_N &lt;dbl&gt; 0.3993264, 0.6519389, 0.5692523, 0.7251908, 0.507... ## $ clr_P &lt;dbl&gt; -2.599180, -2.468221, -2.423432, -2.327678, -2.50... ## $ clr_K &lt;dbl&gt; 0.7945826, 0.8242433, 0.7214698, 0.7597218, 0.676... ## $ clr_Ca &lt;dbl&gt; -0.6220171, -0.7470790, -0.6610863, -0.6945233, -... ## $ clr_Mg &lt;dbl&gt; -1.577529, -1.775074, -1.730285, -1.991205, -1.51... ## $ clr_Fv &lt;dbl&gt; 3.604817, 3.514191, 3.524081, 3.528494, 3.430364,... ## $ RendVendable &lt;dbl&gt; 37.55050, 46.00890, 42.95690, 49.24620, 41.86690,... ## $ rv_cut &lt;dbl&gt; 41.33053, 41.33053, 41.33053, 41.33053, 41.33053,... ## $ yieldClass &lt;chr&gt; &quot;LY&quot;, &quot;HY&quot;, &quot;HY&quot;, &quot;HY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;... ## $ Maturity5 &lt;chr&gt; &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-se... ## $ Cultivar &lt;chr&gt; &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;... ## $ pred_yield &lt;chr&gt; &quot;HY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;... ## $ debal &lt;dbl&gt; 0.48988609, 0.16712719, 0.23425051, 0.21198871, 0... 4.4 Perturbation effect of some elements on the whole This subsection illustrates the principle that strictly positive data constrained to some whole are inherently related to each other. Changing a proportion (so, perturbation on some proportion(s)) inherently affects at least another proportion, because such data convey only relative information (Aitchison, 1982). leaf_clr_o stands for original clr values of the tidded test set test_df. # Compute (or select here) the clrs leaf_clr_o &lt;- test_df %&gt;% select(clr_no) #leaf_clr_o &lt;- test_df %&gt;% # filter(debal &gt;= quantile(train_df$debal, p = .75)) %&gt;% # select(clr_no) summary(leaf_clr_o) ## clr_N clr_P clr_K clr_Ca ## Min. :0.0000 Min. :-3.159 Min. :-0.3560 Min. :-1.98953 ## 1st Qu.:0.6253 1st Qu.:-2.171 1st Qu.: 0.2671 1st Qu.:-1.16304 ## Median :0.7282 Median :-2.005 Median : 0.4315 Median :-1.00005 ## Mean :0.7227 Mean :-2.004 Mean : 0.4567 Mean :-1.00711 ## 3rd Qu.:0.8349 3rd Qu.:-1.838 3rd Qu.: 0.6078 3rd Qu.:-0.84266 ## Max. :1.2106 Max. :-1.186 Max. : 1.8047 Max. : 0.06082 ## clr_Mg clr_Fv ## Min. :-2.7207 Min. :2.969 ## 1st Qu.:-1.9545 1st Qu.:3.472 ## Median :-1.7108 Median :3.547 ## Mean :-1.7294 Mean :3.561 ## 3rd Qu.:-1.5006 3rd Qu.:3.640 ## Max. :-0.6952 Max. :4.167 Let’s perturb the original clr values for N and P. # Perturb the original clrs pert_col &lt;- c(1, 2) # the column indices which is perturbed: clr_N and clr_K respectively perturbation &lt;- c(0.2, 0.2) # the amount added to the clr of the pert_col, same lenght as pert_col leaf_clr_f &lt;- leaf_clr_o for (i in seq_along(pert_col)) { leaf_clr_f[, pert_col[i]] &lt;- leaf_clr_f[, pert_col[i]] * (1 + perturbation[i]) } summary(leaf_clr_f) ## clr_N clr_P clr_K clr_Ca ## Min. :0.0000 Min. :-3.791 Min. :-0.3560 Min. :-1.98953 ## 1st Qu.:0.7503 1st Qu.:-2.605 1st Qu.: 0.2671 1st Qu.:-1.16304 ## Median :0.8739 Median :-2.406 Median : 0.4315 Median :-1.00005 ## Mean :0.8672 Mean :-2.404 Mean : 0.4567 Mean :-1.00711 ## 3rd Qu.:1.0019 3rd Qu.:-2.206 3rd Qu.: 0.6078 3rd Qu.:-0.84266 ## Max. :1.4528 Max. :-1.423 Max. : 1.8047 Max. : 0.06082 ## clr_Mg clr_Fv ## Min. :-2.7207 Min. :2.969 ## 1st Qu.:-1.9545 1st Qu.:3.472 ## Median :-1.7108 Median :3.547 ## Mean :-1.7294 Mean :3.561 ## 3rd Qu.:-1.5006 3rd Qu.:3.640 ## Max. :-0.6952 Max. :4.167 The next one transforms clrs (original and perturbed clrs) back to compositions. # From clrs to compositions leaf_o &lt;- apply(leaf_clr_o, 1, function(x) exp(x) / sum(exp(x))) %&gt;% t() leaf_f &lt;- apply(leaf_clr_f, 1, function(x) exp(x) / sum(exp(x))) %&gt;% t() Then, we plot the original and perturbed ionomes to check a general tendency. Observation column plots the original “N”, “P”, “K”, “Ca”, “Mg” and “Fv” compositions, Perturbation represents new compositions after perturbation and Difference column stands for perturbation occured in the Observation to yied new compositions. Data are tidded before. rshleaf_o &lt;- melt(data.frame(leaf_o)) %&gt;% mutate(vector = rep(&quot;Observation&quot;, nrow(.))) ## Using as id variables rshleaf_f &lt;- melt(data.frame(leaf_f)) %&gt;% mutate(vector = rep(&quot;Perturbation&quot;, nrow(.))) ## Using as id variables rshdf &lt;- bind_rows(rshleaf_o, rshleaf_f) rshdf$is_perturbed &lt;- ifelse(rshdf$variable %in% colnames(leaf_o[, pert_col]), &quot;Perturbed&quot;, &quot;Not perturbed&quot;) rshdf$variable &lt;- sub(pattern = &quot;clr_&quot;, replacement = &quot;&quot;, x = rshdf$variable, fixed = TRUE) %&gt;% fct_relevel(&quot;N&quot;, &quot;P&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Mg&quot;, &quot;Fv&quot;) Figure 4.1: Perturbation effect of some elements on the whole. All the components change when the clr of a single component is offset. The components whose clr has been perturbed obviously change the most (2-Perturbation). The component whose clr is the highest (generally Fv) compensate most of the perturbation. Although P clr values have been increased, P proportion decreased globally for the new equilibrium of the simplex. 4.5 Rebalancing a misbalanced sample by perturbation Let’s suppose that we got this point selected at random in imbalanced or misbalanced specimens. set.seed(92559) imbalanced &lt;- train_df[sample(nrow(train_df), 1), ] t(imbalanced) ## [,1] ## NoEssai &quot;412&quot; ## NoBloc &quot;1&quot; ## NoTraitement &quot;9&quot; ## clr_N &quot;0.7735603&quot; ## clr_P &quot;-2.464426&quot; ## clr_K &quot;0.5688289&quot; ## clr_Ca &quot;-1.034959&quot; ## clr_Mg &quot;-1.660053&quot; ## clr_Fv &quot;3.817049&quot; ## RendVendable &quot;34.74147&quot; ## rv_cut &quot;41.33053&quot; ## yieldClass &quot;LY&quot; ## Maturity5 &quot;mid-season&quot; ## Cultivar &quot;Goldrush&quot; ## pred_yield &quot;LY&quot; ## debal &quot;0.2208642&quot; Or even, we could rather use the most imbalanced occurrence, why not ! imbalanced &lt;- train_df[which.max(train_df$debal), ] misbalanced &lt;- imbalanced # copy t(misbalanced) ## [,1] ## NoEssai &quot;200&quot; ## NoBloc &quot;1&quot; ## NoTraitement &quot;2&quot; ## clr_N &quot;0.957698&quot; ## clr_P &quot;-1.83199&quot; ## clr_K &quot;-0.04637332&quot; ## clr_Ca &quot;0.4678508&quot; ## clr_Mg &quot;-2.247862&quot; ## clr_Fv &quot;2.700677&quot; ## RendVendable &quot;30.37194&quot; ## rv_cut &quot;32.6&quot; ## yieldClass &quot;LY&quot; ## Maturity5 &quot;early mid-season&quot; ## Cultivar &quot;Superior&quot; ## pred_yield &quot;LY&quot; ## debal &quot;1.345815&quot; How could we rebalance it? The first step is to find the closest balanced point in the TNs of the corresponding cultivar. Let’s re-compute its Euclidean distances from TNs and identify the TNs’ sample from which the distance is minimum. misbalanced &lt;- misbalanced[clr_no] eucl_dist_misbal &lt;- apply(TNs %&gt;% filter(Cultivar == imbalanced$Cultivar) %&gt;% select(clr_no), 1, function(x) eucl_dist_f(x = x, y = misbalanced)) index_misbal &lt;- which.min(t(data.frame(eucl_dist_misbal))) index_misbal # return the index of the sample ## [1] 50 The closest healthy sample is the one which index is 50 in TNs charing the same cultivar with the new sample. Using this index we could refind the minimum imbalance index value computed. (misbal &lt;- eucl_dist_misbal[index_misbal]) ## [1] 1.345815 The Euclidean distance matches with the corresponding debal value: imbalanced$debal[1] = 1.3458148. The closest point in the TNs subset is this one: target_TNs &lt;- TNs %&gt;% filter(Cultivar == imbalanced$Cultivar) closest &lt;- target_TNs[index_misbal, ] t(closest) ## [,1] ## NoEssai &quot;71&quot; ## NoBloc &quot;3&quot; ## NoTraitement &quot;5&quot; ## clr_N &quot;0.5576154&quot; ## clr_P &quot;-2.078376&quot; ## clr_K &quot;0.4710692&quot; ## clr_Ca &quot;-0.3762287&quot; ## clr_Mg &quot;-2.022806&quot; ## clr_Fv &quot;3.448726&quot; ## RendVendable &quot;37.56831&quot; ## rv_cut &quot;32.6&quot; ## yieldClass &quot;HY&quot; ## Maturity5 &quot;early mid-season&quot; ## Cultivar &quot;Superior&quot; ## pred_yield &quot;HY&quot; Note that Cultivar of the misbalanced and the closest healthy composition are the same. We compute the clr difference between the closest and the misbalanced points. closest = closest[clr_no] clr_diff = closest - misbalanced t(clr_diff) ## [,1] ## clr_N -0.4000826 ## clr_P -0.2463863 ## clr_K 0.5174425 ## clr_Ca -0.8440794 ## clr_Mg 0.2250562 ## clr_Fv 0.7480496 The perturbation vector is that clr difference back-transformed to leaf compositional space. comp_names &lt;- c(&quot;N&quot;, &quot;P&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Mg&quot;, &quot;Fv&quot;) perturbation_vector &lt;- clrInv(clr_diff) names(perturbation_vector) &lt;- comp_names t(perturbation_vector) ## [,1] ## N 0.09679140 ## P 0.11287200 ## K 0.24227737 ## Ca 0.06208853 ## Mg 0.18085523 ## Fv 0.30511547 ## attr(,&quot;class&quot;) ## [1] acomp Next, we should compute the corresponding compositions of the clr coordinates of the misbalanced point, as well as the closest TN point. The vectors could be gathered in a table made up of perturbation vector, misbalanced composition and the closest reference sample (pmc). misbal_comp &lt;- clrInv(misbalanced) names(misbal_comp) &lt;- comp_names closest_comp &lt;- clrInv(closest) names(closest_comp) &lt;- comp_names pmc = rbind(perturbation_vector, misbal_comp, closest_comp) rownames(pmc) = c(&quot;perturbation_vector&quot;,&quot;misbal_comp&quot;,&quot;closest_comp&quot;) pmc ## N P K Ca Mg ## perturbation_vector 0.0967914 0.112872002 0.2422774 0.06208853 0.1808552 ## misbal_comp 0.1282805 0.007881602 0.0470000 0.07860000 0.0052000 ## closest_comp 0.0488500 0.003500000 0.0448000 0.01920000 0.0037000 ## Fv ## perturbation_vector 0.3051155 ## misbal_comp 0.7330379 ## closest_comp 0.8799500 We could even check that the simplex is closed to 1 for each vector. sum(perturbation_vector); sum(misbal_comp); sum(closest_comp) ## [1] 1 ## [1] 1 ## [1] 1 The closest composition minus the misbalanced composition should return the perturbation vector. print(closest_comp - misbal_comp) ## N P K Ca Mg Fv ## [1,] 0.0967914 0.112872 0.2422774 0.06208853 0.1808552 0.3051155 ## attr(,&quot;class&quot;) ## [1] acomp print(perturbation_vector) # for comparison ## N P K Ca Mg Fv ## [1,] 0.0967914 0.112872 0.2422774 0.06208853 0.1808552 0.3051155 ## attr(,&quot;class&quot;) ## [1] acomp Or even, perturb the misbalanced point by the perturbation vector, you should obtain the closest TN point: print(misbal_comp + perturbation_vector) # perturbation ## N P K Ca Mg Fv ## [1,] 0.04885 0.0035 0.0448 0.0192 0.0037 0.87995 ## attr(,&quot;class&quot;) ## [1] acomp print(closest_comp) # for comparison ## N P K Ca Mg Fv ## [1,] 0.04885 0.0035 0.0448 0.0192 0.0037 0.87995 ## attr(,&quot;class&quot;) ## [1] acomp So, the assumption is true. The next codes show the concept using dots plots and histograms for each vector. A data frame is tidded for ggplot. Visualization is better with histograms. df &lt;- data.frame(rbind(misbalanced, closest, clr_diff), vectors = factor(c(&quot;Observation&quot;, &quot;Reference&quot;, &quot;Perturbation&quot;))) df$vectors &lt;- df$vectors %&gt;% fct_relevel(&quot;Observation&quot;, &quot;Reference&quot;, &quot;Perturbation&quot;) dfreshape &lt;- melt(df) # reshapes df for ggplot ## Using vectors as id variables dfreshape &lt;- melt(df) ## Using vectors as id variables dfreshape$variable &lt;- sub(pattern = &quot;clr_&quot;, replacement = &quot;&quot;, x = dfreshape$variable, fixed = TRUE) %&gt;% fct_relevel(&quot;N&quot;, &quot;P&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Mg&quot;, &quot;Fv&quot;) ggplot(data = dfreshape, aes(x = value, y = vectors, colour = vectors)) + geom_point() + facet_wrap(~ variable, scales = &quot;free_x&quot;) + labs(x=&#39;Nutrient clr coordinate&#39;, y =&#39;&#39;) + theme(text=element_text(family=&quot;Arial&quot;, face=&quot;bold&quot;, size=12)) + theme_bw() Figure 4.2: Perturbation vector computation example dotplot using the most imbalanced foliar sample. ggsave(&quot;images/perturb_dotplot.tiff&quot;, width = 7, height = 3) g1 &lt;- ggplot(data = dfreshape, aes(x = variable, y = value, fill = vectors)) + geom_bar(aes(fill = vectors), stat = &quot;identity&quot;, position = position_dodge()) + coord_flip() + theme_bw() + ylab(&quot;Nutrients clr coordinates&quot;) + xlab(&quot;Diagnostic nutrients&quot;) + theme(legend.title = element_blank()) + theme(text = element_text(family = &quot;Arial&quot;, face = &quot;bold&quot;, size = 12)) g1 + scale_fill_discrete(breaks = c(&quot;Observation&quot;,&quot;Reference&quot;,&quot;Perturbation&quot;)) + scale_fill_manual(values=c(&quot;grey50&quot;, &quot;black&quot;, &quot;grey80&quot;)) Figure 4.3: Perturbation vector computation example barplot using the most imbalanced foliar sample. ggsave(&quot;images/perturb_barplot.tiff&quot;, width = 6, height = 4) "]
]
