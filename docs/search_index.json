[
["Chapter-Perturbation-vector.html", "Chapter 4 Perturbation vector theory 4.1 Objective 4.2 Data set and useful libraries 4.3 Dissimilarity index between compositions 4.4 Rebalancing a misbalanced sample by perturbation", " Chapter 4 Perturbation vector theory 4.1 Objective The objective of this chapter is to develop a mathematical workflow useful to adjust the ionome of potato crops for diagnostic purpose. Perturbation in compositional space plays the same role as translation plays in real space. Some natural processes in nature can be interpreted as a change from one composition C1 to another C2 through the application of a perturbation: p ⊕ C1 ====&gt; C2. The difference between the new observation and the closest TN composition can be back-transformed to the compositional space. The obtained vector is the perturbation vector. Theoretically, ionomes of new cultivars could be assigned to the closest healthy ionomic group where nutrient requirements have been already documented by fertilizer trials. I compute a dissimilarity index using the true negative clr as reference. Then, I describe the procedure used to rebalance a misbalanced composition and finally present the results using ggplot2 functions. 4.2 Data set and useful libraries We need package compositions for further clr back-transformation de compositional space. The package reshape will be used to melt an intermediate data frame. As explained at the end of the Chapter 3, I consider as True Negatives (TN) specimens (or healthy points) for this study, observations of the training data set having a high yield (HY) and correctly predicted by the random forest model. library(&quot;tidyverse&quot;) library(extrafont) library(&#39;compositions&#39;) library(&quot;reshape&quot;) train_df = read_csv(&quot;output/train_df.csv&quot;) train_df$group_i = factor(train_df$group_i) TNs = train_df[train_df$yieldClass == &#39;HY&#39; &amp; train_df$pred_yield == &#39;HY&#39;, ] clrNo = c(&quot;clrN&quot;, &quot;clrP&quot;, &quot;clrK&quot;, &quot;clrCa&quot;, &quot;clrMg&quot;, &quot;clrFv&quot;) # for simplicity 4.3 Dissimilarity index between compositions The first step is to compute a dissimilarity index according to the distance from the closest healthy point (the closest TN). I use the Euclidean distance between clr composition as the dissimilarity index. The chunk below shows the custom function used to compute euclidean distance. eucl_dist_f &lt;- function(x, y) { sqrt(sum((x-y)^2)) } For each unbalanced composition, I use the next loop to compute all the euclidean distances between all the compositions in “TNs” of the corresponding group. The computation is possible even if the ionomics groups is unknown. The loop returns the smallest Euclidean distance as the unbalanced index of that composition. The computed debalance (or imbalance) index is stored by a new vector debal. debal &lt;- c() debal_index &lt;- c() for (i in 1:nrow(train_df)) { clr_i &lt;- as.numeric(train_df[i, clrNo]) eucl_dist &lt;- apply(TNs %&gt;% filter(group_i == train_df$group_i[i]) %&gt;% select(clrNo), 1, function(x) eucl_dist_f(x=x, y=clr_i)) debal_index[i] &lt;- which.min(eucl_dist) debal[i] &lt;- eucl_dist[debal_index[i]] } train_df$debal &lt;- debal train_df %&gt;% glimpse() ## Observations: 2,537 ## Variables: 17 ## $ NoEssai &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1... ## $ NoBloc &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3... ## $ NoTraitement &lt;dbl&gt; 1, 2, 4, 6, 7, 8, 2, 3, 4, 6, 7, 1, 2, 4, 6, 7, 8... ## $ clrN &lt;dbl&gt; 0.3321186, 0.4252302, 0.3993264, 0.4885647, 0.720... ## $ clrP &lt;dbl&gt; -2.518325, -2.394957, -2.599180, -2.525335, -2.30... ## $ clrK &lt;dbl&gt; 0.8379383, 1.1387291, 0.7945826, 0.9418880, 0.720... ## $ clrMg &lt;dbl&gt; -1.639076, -2.346167, -1.577529, -1.763195, -1.70... ## $ clrCa &lt;dbl&gt; -0.4794688, -0.5154924, -0.6220171, -0.6426036, -... ## $ clrFv &lt;dbl&gt; 3.466813, 3.692658, 3.604817, 3.500681, 3.432323,... ## $ Cultivar &lt;chr&gt; &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;... ## $ Maturity5 &lt;chr&gt; &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-se... ## $ RendVendable &lt;dbl&gt; 18.94420, 40.35180, 37.55050, 41.01670, 46.79370,... ## $ yieldCutoff &lt;dbl&gt; 41.33053, 41.33053, 41.33053, 41.33053, 41.33053,... ## $ yieldClass &lt;chr&gt; &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;... ## $ group_i &lt;fct&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2... ## $ pred_yield &lt;chr&gt; &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;HY&quot;, &quot;LY&quot;, &quot;HY&quot;, &quot;... ## $ debal &lt;dbl&gt; 0.2915435, 0.3247296, 0.2628167, 0.2987338, 0.000... 4.4 Rebalancing a misbalanced sample by perturbation Let’s suppose that we got this point selected at random in unbalanced specimens. set.seed(932559) unbalanced &lt;- subset(train_df, debal !=0) misbalanced &lt;- unbalanced[sample(nrow(unbalanced), 1), ] t(misbalanced) ## [,1] ## NoEssai &quot;355&quot; ## NoBloc &quot;1&quot; ## NoTraitement &quot;2&quot; ## clrN &quot;0.8015935&quot; ## clrP &quot;-2.00352&quot; ## clrK &quot;0.1670366&quot; ## clrMg &quot;-1.563568&quot; ## clrCa &quot;-0.8453153&quot; ## clrFv &quot;3.443773&quot; ## Cultivar &quot;Mystere&quot; ## Maturity5 &quot;late&quot; ## RendVendable &quot;33.14916&quot; ## yieldCutoff &quot;33.63704&quot; ## yieldClass &quot;LY&quot; ## group_i &quot;1&quot; ## pred_yield &quot;LY&quot; ## debal &quot;0.08489367&quot; Or even, we could rather use the most unbalanced occurrence, … why not ! misbalanced = unbalanced[which.max(unbalanced$debal), ] t(misbalanced) ## [,1] ## NoEssai &quot;275&quot; ## NoBloc &quot;3&quot; ## NoTraitement &quot;3&quot; ## clrN &quot;0.8857481&quot; ## clrP &quot;-1.694469&quot; ## clrK &quot;0.03541537&quot; ## clrMg &quot;-1.262686&quot; ## clrCa &quot;-1.447609&quot; ## clrFv &quot;3.4836&quot; ## Cultivar &quot;Andover&quot; ## Maturity5 &quot;early mid-season&quot; ## RendVendable &quot;23.04251&quot; ## yieldCutoff &quot;39.96972&quot; ## yieldClass &quot;LY&quot; ## group_i &quot;6&quot; ## pred_yield &quot;LY&quot; ## debal &quot;0.8733209&quot; How could we rebalance it? The first step is to find in TNs of the corresponding ionomic group the closest balanced point. Let’s re-compute the Euclidean distance, like for a new (an unknown) point. misbalanced &lt;- misbalanced[clrNo] eucl_dist_misbal &lt;- apply(TNs[, clrNo], 1, function(x) eucl_dist_f(x=x, y=misbalanced)) index_misbal &lt;- which.min(t(data.frame(eucl_dist_misbal))) index_misbal # return the index of the sample ## [1] 401 Let’s re-compute the corresponding debal value for check. misbal = eucl_dist_misbal[index_misbal] misbal ## [1] 0.2411328 The Euclidean distance matches with the corresponding debal value. The closest point in the TNs data set is this one: closest &lt;- TNs[index_misbal, ] t(closest) ## [,1] ## NoEssai &quot;89&quot; ## NoBloc &quot;3&quot; ## NoTraitement &quot;19&quot; ## clrN &quot;0.7458992&quot; ## clrP &quot;-1.613717&quot; ## clrK &quot;0.06536948&quot; ## clrMg &quot;-1.224781&quot; ## clrCa &quot;-1.330142&quot; ## clrFv &quot;3.357371&quot; ## Cultivar &quot;FL 1207&quot; ## Maturity5 &quot;mid-season late&quot; ## RendVendable &quot;38.70164&quot; ## yieldCutoff &quot;36.33134&quot; ## yieldClass &quot;HY&quot; ## group_i &quot;4&quot; ## pred_yield &quot;HY&quot; Note that Ionomics groups of the misbalanced and the closest composition are the same although it’s not the case all the times. The closest healthy point could be found in another ionomics group. I compute the clr difference between the closest and the misbalanced points. closest = closest[clrNo] clr_diff = closest - misbalanced t(clr_diff) ## [,1] ## clrN -0.13984896 ## clrP 0.08075188 ## clrK 0.02995412 ## clrCa 0.11746709 ## clrMg 0.03790527 ## clrFv -0.12622939 The perturbation vector is that clr difference composition back-transformed to leaf compositional space. comp_names &lt;- c(&quot;N&quot;, &quot;P&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Mg&quot;, &quot;Fv&quot;) perturbation_vector &lt;- clrInv(clr_diff) names(perturbation_vector) &lt;- comp_names t(perturbation_vector) ## [,1] ## N 0.1442253 ## P 0.1798238 ## K 0.1709173 ## Ca 0.1865488 ## Mg 0.1722817 ## Fv 0.1462030 ## attr(,&quot;class&quot;) ## [1] acomp Next, we should compute the compositions of the clr coordinates of the misbalanced point, as well as the closest TN point. The vectors could be summed up in a table. misbal_comp &lt;- clrInv(misbalanced) names(misbal_comp) &lt;- comp_names closest_comp &lt;- clrInv(closest) names(closest_comp) &lt;- comp_names pmc = rbind(perturbation_vector, misbal_comp, closest_comp) rownames(pmc) = c(&quot;perturbation_vector&quot;,&quot;misbal_comp&quot;,&quot;closest_comp&quot;) pmc # data frame made up of perturbation vector, misbalanced composition and the closest reference sample ## N P K Ca Mg ## perturbation_vector 0.1442253 0.1798238 0.1709173 0.1865488 0.1722817 ## misbal_comp 0.0660000 0.0050000 0.0282000 0.0064000 0.0077000 ## closest_comp 0.0645800 0.0061000 0.0327000 0.0081000 0.0090000 ## Fv ## perturbation_vector 0.146203 ## misbal_comp 0.886700 ## closest_comp 0.879520 We could even check that the simplex is closed to 1 for each vector. sum(perturbation_vector); sum(misbal_comp); sum(closest_comp) ## [1] 1 ## [1] 1 ## [1] 1 The closest composition minus the misbalanced composition should return the perturbation vector. print(closest_comp - misbal_comp) # soustraction ## N P K Ca Mg Fv ## [1,] 0.1442253 0.1798238 0.1709173 0.1865488 0.1722817 0.146203 ## attr(,&quot;class&quot;) ## [1] acomp print(perturbation_vector) # for comparison ## N P K Ca Mg Fv ## [1,] 0.1442253 0.1798238 0.1709173 0.1865488 0.1722817 0.146203 ## attr(,&quot;class&quot;) ## [1] acomp Or even, perturb the misbalanced point by the perturbation vector, you should obtain the closest TN point: print(misbal_comp + perturbation_vector) # perturbation ## N P K Ca Mg Fv ## [1,] 0.06458 0.0061 0.0327 0.0081 0.009 0.87952 ## attr(,&quot;class&quot;) ## [1] acomp print(closest_comp) # for comparison ## N P K Ca Mg Fv ## [1,] 0.06458 0.0061 0.0327 0.0081 0.009 0.87952 ## attr(,&quot;class&quot;) ## [1] acomp So, the assumption is true. The next codes show the concept using plots. I handle a data frame for ggplot. d = data.frame(rbind(misbalanced, closest, clr_diff)) # mis, cl, per vectors = c(&quot;observation&quot;, &quot;reference&quot;, &quot;perturbation&quot;) d$vectors = factor(vectors) dreshape = melt(d) # reshapes d for ggplot ## Using vectors as id variables dreshape ## vectors variable value ## 1 observation clrN 0.88574813 ## 2 reference clrN 0.74589917 ## 3 perturbation clrN -0.13984896 ## 4 observation clrP -1.69446870 ## 5 reference clrP -1.61371682 ## 6 perturbation clrP 0.08075188 ## 7 observation clrK 0.03541537 ## 8 reference clrK 0.06536948 ## 9 perturbation clrK 0.02995412 ## 10 observation clrCa -1.44760862 ## 11 reference clrCa -1.33014153 ## 12 perturbation clrCa 0.11746709 ## 13 observation clrMg -1.26268628 ## 14 reference clrMg -1.22478102 ## 15 perturbation clrMg 0.03790527 ## 16 observation clrFv 3.48360010 ## 17 reference clrFv 3.35737071 ## 18 perturbation clrFv -0.12622939 The next two chunks plot with dots and histograms for each vector. Visualization is better with histograms. options(repr.plot.width = 6, repr.plot.height = 3) ggplot(data = dreshape, aes(x = value, y = vectors)) + geom_point() + facet_wrap(~ variable, scales = &quot;free_x&quot;) + labs(x=&#39;clr coordinate&#39;, y =&#39;&#39;) + theme(text=element_text(family=&quot;Arial&quot;, face=&quot;bold&quot;, size=12)) Figure 4.1: Perturbation vector computation example dotplot using the most imbalanced foliar sample. #ggsave(&quot;images/perturb_dotplot.tiff&quot;, width = 6, height = 4) options(repr.plot.width = 5, repr.plot.height = 3) ggplot(data=dreshape, aes(x=variable, y=value, fill=vectors)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge()) + coord_flip() + theme_bw() + theme(legend.title=element_blank()) + theme(text=element_text(family=&quot;Arial&quot;, face=&quot;bold&quot;, size=12)) Figure 4.2: Perturbation vector computation example barplot using the most imbalanced foliar sample. #ggsave(&quot;images/perturb_barplot.tiff&quot;, width = 6, height = 4) "]
]
