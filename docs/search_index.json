[
["index.html", "Balancing the nutritional status of potato crops. Chapter 1 Data processing 1.1 Objective 1.2 Useful libraries for data handling 1.3 Québec potato data set 1.4 Selection of useful variables 1.5 Arranging the data frame 1.6 Cultivar classes correction 1.7 Summarise and backup", " Balancing the nutritional status of potato crops. Zonlehoua Coulibali and Serge-Étienne Parent 2019-07-25 Chapter 1 Data processing 1.1 Objective This chapter is the first of a series of R markdown codes aiming to describe computations methodology used to derive the results and conclusions of potato nutrient diagnosis article. The data set is a collection of potato surveys and nitrogen (N), phosphorous (P) and potassium (K) fertilizer trials conducted in Quebec from 1970 to 2017 between the US border at the 45^th parallel and the Northern limit of cultivation at the 49^th parallel. The useful variables are the first mature leaf (4^th from top, sampled at the beginning of blossom stage) nitrogen, phosphorus, potassium, calcium (Ca) and magnesium (Mg) compositions, cultivars used in experiments and tuber marketable yield. These variables are extracted from the Québec potato raw data table (raw_potato_df.csv) and tidded to obtain useful variables for cultivars clustering assessment (Chapter 2), tuber yield prediction (Chapter 3) and assessment of perturbation vector concept (Chapter 4). A previous exploration has shown that oligoelements contained too many missing values, for this reason these elements were excluded from analysis. The chapter ends with the backup of a processed data frame useful for next chapters. 1.2 Useful libraries for data handling I need package tidyverse which loads a set of packages for easy data manipulation and visualization. I used Amelia for missing data vizualisation, robCompositions to robustely impute missing values in compositional data using knn methods, compositions to transforme compositions into compositionnal space. library(&quot;tidyverse&quot;) library(&#39;Amelia&#39;) library(&quot;robCompositions&quot;) library(&quot;compositions&quot;) 1.3 Québec potato data set I load the Québec potato raw data set raw_potato_df.csv available for the project in the data folder. raw_potato_df &lt;- read_csv(&quot;data/raw_potato_df.csv&quot;) 1.4 Selection of useful variables I create custom vectors of attributes which help select useful data columns for computations. The year of experiment is not needed instead it permits to know how long ago expériements have been monitored. Geographical coordinates will be needed to map experimental sites locations later. keys_col &lt;- c(&#39;NoEssai&#39;, &#39;NoBloc&#39;, &#39;NoTraitement&#39;) longNameMacro &lt;- c(&quot;AnalyseFoliaireN&quot;,&quot;AnalyseFoliaireP&quot;,&quot;AnalyseFoliaireK&quot;, &quot;AnalyseFoliaireCa&quot;,&quot;AnalyseFoliaireMg&quot;) extra_col &lt;- c(&#39;Annee&#39;, &#39;LatDD&#39;, &#39;LonDD&#39;, &#39;AnalyseFoliaireStade&#39;) cultivarAndyield &lt;- c(&#39;Cultivar&#39;, &#39;Maturity5&#39;, &#39;RendVendable&#39;) useful_col &lt;- c(keys_col, extra_col, cultivarAndyield, longNameMacro) macroElements &lt;- c(&quot;N&quot;, &quot;P&quot;, &quot;K&quot;, &quot;Ca&quot;, &quot;Mg&quot;) # for simplicity The reduced data frame becomes leaf_df which stands for the diagnostic leaves macroelements composition data frame combining corresponding cultivars data, marketable yield, year of experiment and sites geographical coordinates. leaf_df &lt;- raw_potato_df %&gt;% select(useful_col) colnames(leaf_df)[which(names(leaf_df) %in% longNameMacro)] &lt;- macroElements glimpse(leaf_df) ## Observations: 12,991 ## Variables: 15 ## $ NoEssai &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... ## $ NoBloc &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,... ## $ NoTraitement &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6,... ## $ Annee &lt;dbl&gt; 2003, 2003, 2003, 2003, 2003, 2003, 2003,... ## $ LatDD &lt;dbl&gt; 46.75306, 46.75306, 46.75306, 46.75306, 4... ## $ LonDD &lt;dbl&gt; -72.33861, -72.33861, -72.33861, -72.3386... ## $ AnalyseFoliaireStade &lt;chr&gt; &quot;10% fleur&quot;, &quot;10% fleur&quot;, &quot;10% fleur&quot;, &quot;1... ## $ Cultivar &lt;chr&gt; &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Goldrush&quot;, &quot;Gold... ## $ Maturity5 &lt;chr&gt; &quot;mid-season&quot;, &quot;mid-season&quot;, &quot;mid-season&quot;,... ## $ RendVendable &lt;dbl&gt; 18.9442, 40.3518, 33.0379, 37.5505, 46.00... ## $ N &lt;dbl&gt; 3.805, 3.356, 3.657, 3.610, 4.983, 4.277,... ## $ P &lt;dbl&gt; 0.22, 0.20, 0.22, 0.18, 0.22, 0.21, 0.28,... ## $ K &lt;dbl&gt; 6.31, 6.85, 6.44, 5.36, 5.92, 6.73, 5.75,... ## $ Ca &lt;dbl&gt; 1.69, 1.31, 1.13, 1.30, 1.23, 1.38, 1.17,... ## $ Mg &lt;dbl&gt; 0.53, 0.21, 0.32, 0.50, 0.44, 0.45, 0.51,... 1.5 Arranging the data frame I set trial number NoEssai as factor, relevel categorical maturity order variable and choose cultivar Superior as reference as it has the maximum number of observations. Then, abundance of cultivars is ploted. percentage &lt;- round(with(leaf_df, prop.table(table(Cultivar)) * 100), 2) distribution &lt;- with(leaf_df, cbind(numbOfsamples = table(Cultivar), percentage = percentage)) distribution &lt;- data.frame(cbind(distribution, rownames(distribution))) colnames(distribution)[3] &lt;- &quot;Cultivar&quot; distribution$numbOfsamples &lt;- as.numeric(as.character(distribution$numbOfsamples)) distribution$percentage &lt;- as.numeric(as.character(distribution$percentage)) Figure 1.1: Repported cultivars abundance in the potato data frame. leaf_df$NoEssai &lt;- as.factor(leaf_df$NoEssai) leaf_df$Cultivar &lt;- relevel(factor(leaf_df$Cultivar), ref = &quot;Superior&quot;) leaf_df$Maturity5 &lt;- ordered(leaf_df$Maturity5, levels = c(&quot;early&quot;,&quot;early mid-season&quot;, &quot;mid-season&quot;,&quot;mid-season late&quot;,&quot;late&quot;)) I portrait missing values for the sake of imputation. As explained in the section ??, I will retain after this processing only reasonably imputable data i.e., missing data of a sample less than half the number of studied attributes. The next cell maps the portrait of missing values. leafIonome &lt;- leaf_df[macroElements] missmap(leafIonome) Figure 1.2: Portrait of missing macroelements. This figure compiles the samples identifiers on the Y axis and macroelements on the X axis. A complete horizontal unique color band indicates wether the 5 elements are totally observed (blue band) or totally missing (red band). Only N and P have missing values that will be imputed and retained at the end. The totally missing compositions will be removed. The next cell initializes this process. # keep track of empty rows: leaf_df$leaf_allNA &lt;- apply(leaf_df[macroElements], 1, function(X) all(is.na(X))) # keep track of rows where there is any NA: leaf_df$leaf_anyNA &lt;- apply(leaf_df[macroElements], 1, function(X) any(is.na(X))) # number of NAs (missing values): leaf_df$leaf_countNA &lt;- apply(leaf_df[macroElements], 1, function(X) sum(is.na(X))) The next cell performs the imputation. Since the imputation is a time-consuming process, we saved it in a csv stored in the subfolder output and have put a switch to put on if one wants to perform the computation again. The imputation is made by KNNs in the Aitchison (compositions-friendly) metric for rows where there are 1 or 2 missing values, i.e. filter(leaf_countNA &lt;= 3). # Warning: could be a long process perform_imputation &lt;- FALSE # set to FALSE if you want to load the saved file if (perform_imputation) { set.seed(628125) leaf_imp &lt;- leaf_df %&gt;% filter(leaf_countNA &lt;= 3) %&gt;% select(macroElements) %&gt;% impKNNa(as.matrix(.), metric = &quot;Aitchison&quot;, k = 6, primitive = TRUE, normknn = TRUE, adj = &#39;median&#39;) leaf_complete &lt;- leaf_df %&gt;% select(macroElements) leaf_complete[leaf_df$leaf_countNA &lt;= 3, ] &lt;- leaf_imp$xImp names(leaf_complete) &lt;- paste0(names(leaf_complete), &quot;_imp&quot;) write_csv(leaf_complete, &quot;output/leaf_complete.csv&quot;) } else { leaf_complete &lt;- read_csv(&quot;output/leaf_complete.csv&quot;) } ## Parsed with column specification: ## cols( ## N_imp = col_double(), ## P_imp = col_double(), ## K_imp = col_double(), ## Ca_imp = col_double(), ## Mg_imp = col_double() ## ) With the next cell I append imputed columns to the data frame. The nutrients diagnosis will be done with imputed compositions. leaf_df &lt;- bind_cols(leaf_df, leaf_complete) leaf_df &lt;- leaf_df %&gt;% select(-c(&quot;leaf_allNA&quot;, &quot;leaf_anyNA&quot;)) Compositional data are data where the elements of the composition are non-negative and sum to unity. I compute Fv standing for filling value, an amalgamation of all other elements closing the simplex to 100%. leaf_df &lt;- leaf_df %&gt;% mutate(sum_imp = rowSums(select(., paste0(macroElements, &quot;_imp&quot;))), Fv_imp = 100 - sum_imp) %&gt;% select(-sum_imp) if (!&quot;Fv&quot; %in% macroElements) macroElements &lt;- c(macroElements, &quot;Fv&quot;) I use centered log-ratio (clr) transformation for discriminant analysis and perturbation vector concept assessment.The next cell performs this calculation. The clr coordinates are computed in an external (intermediate) data table. leaf_composition &lt;- leaf_df %&gt;% select(paste0(macroElements, &quot;_imp&quot;)) %&gt;% acomp(.) leaf_clr &lt;- clr(leaf_composition) %&gt;% unclass() %&gt;% as_tibble() names(leaf_clr) &lt;- paste0(&quot;clr_&quot;, macroElements) write_csv(leaf_clr, &quot;output/leaf_clr.csv&quot;) The next cell binds these clr-transformed compositions to the raw composition data frame and retains useful columns. I also used this cell to discard all the samples with too many missing compositions. leaf_df &lt;- bind_cols(leaf_df, leaf_clr) leaf_df &lt;- leaf_df %&gt;% select(keys_col, extra_col, cultivarAndyield, &quot;leaf_countNA&quot;, starts_with(&quot;clr&quot;)) %&gt;% filter(leaf_countNA &lt;= 3) 1.6 Cultivar classes correction From a previous checking, I noticed that cultivars Mystere and Vivaldi have different repported maturity classes in the data set, mid-season late and late for Mystere, then early mid-season and mid-season for Vivaldi respectively. Their new maturity classes names are based on a majority vote for this study. The next cell perform this correction. I also make missing values explicit for this categorical variable. leaf_df$Maturity5[leaf_df$Cultivar == &quot;Mystere&quot;] &lt;- &quot;late&quot; leaf_df$Maturity5[leaf_df$Cultivar == &quot;Vivaldi&quot;] &lt;- &quot;early mid-season&quot; leaf_df$Cultivar &lt;- forcats::fct_explicit_na(leaf_df$Cultivar) # makes missing values explicit. 1.7 Summarise and backup Finally, I summarized the processed data frame to record the years of begining and ending of experiment, the remaining number of experiments, cultivars and maturity classes. The definitive leaves data frame is stored as leaf_clust_df.csv in output subfolder as it is an intermediate file, for cluster analysis (Chapter 2). leaf_df %&gt;% summarise(start_year = min(Annee, na.rm = TRUE), end_year = max(Annee, na.rm = TRUE), numb_trials = n_distinct(NoEssai, na.rm = TRUE), numb_cultivars = n_distinct(Cultivar, na.rm = TRUE), numb_maturityClasses = n_distinct(Maturity5, na.rm = TRUE)) ## # A tibble: 1 x 5 ## start_year end_year numb_trials numb_cultivars numb_maturityClasses ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1970 2017 4714 59 5 write_csv(leaf_df, &#39;output/leaf_clust_df.csv&#39;) "]
]
