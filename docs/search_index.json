[
["cluster-analysis-of-cultivars-using-foliar-npkmgca-clr-coordinates.html", "Chapter 2 Cluster analysis of cultivars using foliar NPKMgCa clr coordinates", " Chapter 2 Cluster analysis of cultivars using foliar NPKMgCa clr coordinates We need a set of packages for data handling. Others will be loaded whenever needed. library(&quot;tidyverse&quot;) # loads dplyr &amp; ggplot2 library(&#39;ellipse&#39;) # plot ellipses library(&quot;mvoutlier&quot;) # sign1, multivariate outliers detection library(&quot;ade4&quot;) # discriminant analysis library(&quot;vegan&quot;) # data clustering library(&quot;extrafont&quot;) # Changing Fonts for Graphs We will also use a custom function for discriminant analysis plots. source(&#39;https://raw.githubusercontent.com/essicolo/AgFun/master/plotDA_trad.R&#39;) source(&quot;https://raw.githubusercontent.com/essicolo/AgFun/master/plotDA_gg.R&quot;) Load data file from previous 1.0_data preprocessing.Rmd codes. fol_df &lt;- read.csv2(&quot;data/fol_df.csv&quot;) # Key columns selection keys_col &lt;- c(&#39;NoEssai&#39;, &#39;NoBloc&#39;, &#39;NoTraitement&#39;) clr_no &lt;- c(&quot;clr_N&quot;, &quot;clr_P&quot;, &quot;clr_K&quot;, &quot;clr_Mg&quot;, &quot;clr_Ca&quot;, &quot;clr_Fv&quot;) cult_yield &lt;- c(&#39;Cultivar&#39;, &#39;Maturity5&#39;, &#39;AnalyseFoliaireStade&#39;, &#39;RendVendable&#39;) For cluster analysis, keep only high yielders, i.e. yield 65% quantile cutter for each cultivar. The cutQ table contains the yield delimiter for each cultivar. cutQ &lt;- fol_df %&gt;% group_by(Cultivar) %&gt;% select(RendVendable) %&gt;% summarise_if(is.numeric, quantile, probs=0.65, na.rm = TRUE) %&gt;% rename(rv_cut = RendVendable) ## Adding missing grouping variables: `Cultivar` The cutQ table is used to add the variable yieldClass to fol_df. fol_df &lt;- fol_df %&gt;% left_join(cutQ, by = &quot;Cultivar&quot;) %&gt;% mutate(yieldClass = fct_relevel(ifelse(RendVendable &gt;= rv_cut, &quot;HY&quot;, &quot;LY&quot;), &quot;LY&quot;)) For sake of verification, we compute average yield per yieldClass. meanYield = fol_df %&gt;% group_by(yieldClass) %&gt;% select(RendVendable) %&gt;% summarise_if(is.numeric, mean, na.rm = TRUE) ## Adding missing grouping variables: `yieldClass` meanYield ## # A tibble: 3 x 2 ## yieldClass RendVendable ## &lt;fct&gt; &lt;dbl&gt; ## 1 LY 24.8 ## 2 HY 40.4 ## 3 &lt;NA&gt; NaN clr centroids computation Compositional data transformation is done in the loaded file. We keep only clr-transformed coordinates for high yielders, at 10 % blossom (AnalyseFoliaireStade = 10% fleur). highYielders_df &lt;- fol_df %&gt;% mutate(isNA = apply(.[c(clr_no, cult_yield)], 1, anyNA)) %&gt;% mutate(is10pcf = AnalyseFoliaireStade == &quot;10% fleur&quot;) %&gt;% filter(!isNA &amp; is10pcf &amp; yieldClass == &quot;HY&quot; &amp; NoEssai != &quot;2&quot;) %&gt;% select(one_of(keys_col, clr_no, cult_yield)) %&gt;% droplevels() nrow(highYielders_df) ## [1] 1401 So, 1401 lines of observations (or samples) will be used for clustering. Check how many rows of data you have for each cultivar: percentage &lt;- round(with(highYielders_df, prop.table(table(Cultivar)) * 100), 2) distribution &lt;- with(highYielders_df, cbind(nHY = table(Cultivar), percent = percentage)) distribution &lt;- data.frame(cbind(distribution, rownames(distribution))) colnames(distribution)[3] &lt;- &quot;Cultivar&quot; distribution$nHY &lt;- as.numeric(as.character(distribution$nHY)) # nHY = number of samples distribution$percent &lt;- as.numeric(as.character(distribution$percent)) # percentage distribution %&gt;% arrange(desc(nHY)) # arrange in descending order ## nHY percent Cultivar ## 1 233 16.63 Goldrush ## 2 203 14.49 Superior ## 3 158 11.28 FL 1207 ## 4 132 9.42 Chieftain ## 5 88 6.28 Atlantic ## 6 74 5.28 Kennebec ## 7 65 4.64 FL 1533 ## 8 58 4.14 Coastal Russet ## 9 51 3.64 Snowden ## 10 27 1.93 Mystere ## 11 26 1.86 AC Belmont ## 12 25 1.78 Yukon Gold ## 13 24 1.71 Shepody ## 14 23 1.64 Aquilon ## 15 19 1.36 Russet Burbank ## 16 18 1.28 Vivaldi ## 17 17 1.21 Andover ## 18 17 1.21 Estima ## 19 17 1.21 Norland ## 20 16 1.14 Pommerelle ## 21 11 0.79 Reba ## 22 9 0.64 Bijou Rouge ## 23 7 0.50 Argos ## 24 7 0.50 Dark Red Chieftain ## 25 7 0.50 Pike ## 26 6 0.43 Roko ## 27 6 0.43 Waneta ## 28 5 0.36 AC Chaleur ## 29 5 0.36 Amandine ## 30 5 0.36 Prospect ## 31 5 0.36 Red Maria ## 32 5 0.36 Russet Norkota ## 33 4 0.29 Lanorma ## 34 4 0.29 Red Cloud ## 35 4 0.29 W 1386 ## 36 3 0.21 Carolina ## 37 3 0.21 Nordonna ## 38 3 0.21 Sifra ## 39 2 0.14 Ambra ## 40 2 0.14 Kanona ## 41 2 0.14 Keuka Gold ## 42 2 0.14 Lamoka ## 43 1 0.07 Frontier Russet ## 44 1 0.07 Harmony ## 45 1 0.07 Krantz Some cultivars are well represented, like Goldrush and Superior. Let’s compute numbers of cultivars and trials for high yielders. data.frame(nbr_cultivars = n_distinct(highYielders_df$Cultivar, na.rm = T), nbr_trials = n_distinct(highYielders_df$NoEssai, na.rm = T)) ## nbr_cultivars nbr_trials ## 1 45 149 A table with cultivars, maturity classes and median clr values (i.e., Centroids). highYielders_clr &lt;- highYielders_df %&gt;% group_by(Cultivar, Maturity5) %&gt;% select(Cultivar, Maturity5, starts_with(&quot;clr&quot;)) %&gt;% summarise_all(list(median)) highYielders_clr ## # A tibble: 45 x 8 ## # Groups: Cultivar [45] ## Cultivar Maturity5 clr_N clr_P clr_K clr_Mg clr_Ca clr_Fv ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AC Belmont early 0.698 -2.00 0.662 -1.62 -1.12 3.46 ## 2 AC Chaleur early 0.688 -1.98 0.352 -1.54 -1.02 3.50 ## 3 Amandine mid-season 0.526 -2.30 0.525 -1.59 -0.680 3.51 ## 4 Ambra mid-season 0.713 -1.98 0.275 -1.39 -1.08 3.46 ## 5 Andover early mid-season 0.812 -2.17 0.749 -2.28 -0.808 3.61 ## 6 Aquilon mid-season 0.783 -1.86 0.387 -1.83 -0.901 3.48 ## 7 Argos late 0.767 -1.77 0.570 -1.70 -1.28 3.43 ## 8 Atlantic mid-season 0.784 -1.87 0.155 -1.50 -1.09 3.56 ## 9 Bijou Rouge early 0.942 -1.93 0.563 -1.93 -1.12 3.61 ## 10 Carolina early 0.598 -2.19 0.131 -1.34 -0.837 3.63 ## # ... with 35 more rows Identify outliers with a criterion of 0.975 by cultivar, if cultivars contain at leat 20 rows. If less than 20 rows, all rows are kept. The new data frame is used for discriminant analysis lda_df. highYielders_df_IO &lt;- highYielders_df %&gt;% group_by(Cultivar) %&gt;% select(starts_with(&quot;clr&quot;)) %&gt;% do({ if (nrow(.) &lt; 20) { IO = rep(1, nrow(.)) } else { IO = sign1(.[,-1], qcrit=0.975)$wfinal01 } cbind(.,IO) }) lda_df &lt;- highYielders_df_IO %&gt;% filter(IO == 1) %&gt;% droplevels() nrow(lda_df) ## [1] 1244 lda_df %&gt;% head() ## # A tibble: 6 x 8 ## # Groups: Cultivar [1] ## Cultivar clr_N clr_P clr_K clr_Mg clr_Ca clr_Fv IO ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AC Belmont 0.708 -2.32 0.718 -1.75 -0.813 3.45 1 ## 2 AC Belmont 0.610 -2.35 0.730 -1.81 -0.739 3.56 1 ## 3 AC Belmont 0.727 -1.87 0.724 -1.68 -1.34 3.44 1 ## 4 AC Belmont 0.752 -1.89 0.657 -1.66 -1.28 3.42 1 ## 5 AC Belmont 0.610 -2.01 0.664 -1.59 -1.14 3.46 1 ## 6 AC Belmont 0.723 -1.96 0.616 -1.59 -1.22 3.42 1 Axis reduction with LDA Linear Discriminant Analysis lda_df$Cultivar &lt;- factor(lda_df$Cultivar) pca_fol &lt;- dudi.pca(lda_df[clr_no], scannf = FALSE, scale = FALSE) lda_fol &lt;- discrimin(dudi = pca_fol, fac = factor(lda_df$Cultivar), scannf = FALSE) lda_fol_score = lda_fol$li lda_fol_loading = lda_fol$fa lda_fol_group = lda_df$Cultivar n_cultivar = table(lda_df$Cultivar) # Do not schow Cultivars whose number of occurrences is &lt; 5 n_filter &lt;- lda_fol_group %in% names(n_cultivar[n_cultivar &gt;= 5]) filter_cultivars &lt;- names(n_cultivar[n_cultivar &gt;= 5]) lda_df_filter &lt;- lda_df[n_filter, ] The distance biplot, a first view. options(repr.plot.width = 6, repr.plot.height = 6) plot_lda(score=lda_fol_score[n_filter, ], loading=lda_fol_loading[n_filter, ], group = lda_fol_group[n_filter], ell_dev=FALSE, ell_err= FALSE, #TRUE, scale_load = 0.5, level=0.95, legend=FALSE, label=TRUE, transparency=0.3, xlim = c(-2.5, 2), ylim = c(-3.5, 3.5), points=F) Figure 2.1: Discriminant distance biplot of potato cultivars. K-means clustering using clr centroïds for high yielders The next data frame is the same as highYielders_clr without maturity classes. highYieldersCentroids &lt;- highYielders_df %&gt;% group_by(Cultivar) %&gt;% select(starts_with(&quot;clr&quot;)) %&gt;% summarise_all(list(median)) We use Calinski-Harabasz (1974) criterion (package vegan) for clustering. set.seed(194447) highYieldersKmeans &lt;- cascadeKM(highYieldersCentroids[, -1], inf.gr = 3, sup.gr = 8, criterion = &quot;calinski&quot;) Plot K-means clustering results. options(repr.plot.width = 6, repr.plot.height = 4) plot(highYieldersKmeans) Figure 2.2: K-means partitions comparison (calinski criterion). The red dot of the right hand side graph shows 4 optimal clustering partitions. Check the differnt partitions data frame. highYieldersKmeans$partition %&gt;% head() ## 3 groups 4 groups 5 groups 6 groups 7 groups 8 groups ## 1 3 3 4 3 7 3 ## 2 1 2 5 4 4 1 ## 3 2 1 1 5 6 2 ## 4 1 2 5 4 4 7 ## 5 3 4 3 6 2 5 ## 6 3 4 3 3 7 3 Consider 4 groups from clustering according to calinski criterion, this corresponds to the column 2 or use 4 groups as column name directly, and add it up to the previous data frame. highYieldersCentroids$kgroup &lt;- highYieldersKmeans$partition[, &quot;4 groups&quot;] Compute discriminant scores centroïdes for cultivars. lda_centroids &lt;- lda_fol_score %&gt;% mutate(group = lda_fol_group) %&gt;% group_by(group) %&gt;% summarise_all(list(mean)) Plot Cultivar groups in LDA with a custom function. options(repr.plot.width = 6, repr.plot.height = 6) #png(&quot;images/clustering.png&quot;, width=3000, height=1400, res = 300) plot_lda(score=lda_fol_score[n_filter, ], loading=lda_fol_loading[n_filter, ], group = lda_fol_group[n_filter], ell_dev=FALSE, ell_err= FALSE, #TRUE, scale_load = 0.4, level=0.95, legend=FALSE, label=TRUE, transparency=0.4, xlim = c(-2.5, 2), ylim = c(-3.5, 3.5), points=F) coll = factor(highYieldersCentroids[highYieldersCentroids$Cultivar %in% filter_cultivars, &#39;kgroup&#39;][[1]]) # remove the cultivar column points(lda_centroids[lda_centroids$group %in% filter_cultivars, c(&#39;DS1&#39;, &#39;DS2&#39;)], pch = 19, col = coll, # colours dots for groups or clusters. cex = 0.9) legend(-2.5, 3, legend = paste(rep(&#39;cluster&#39;, nlevels(coll)), as.numeric(levels(coll))), pch = 19, col = unique(coll), cex = 0.9) Figure 2.3: Discriminant distance biplot of potato cultivars showing ionomics groups. It’s a bit difficult to colour cultivar names in the plot with the custom function. Use functions from packages ggplot2, ggrepel and plotly instead. The package ggplot2 is already loaded with tidyverse. New data frames are created with useful variables. library(&quot;ggrepel&quot;) library(&quot;plotly&quot;) cultivars_filtre &lt;- data.frame(Cultivar = filter_cultivars, i_group=coll) df &lt;- data.frame( score = lda_fol_score[n_filter, ], loadings = lda_fol_loading[n_filter,], Cultivar = lda_fol_group[n_filter] ) df &lt;- df %&gt;% left_join(cultivars_filtre, by=&quot;Cultivar&quot;) df %&gt;% head() ## score.DS1 score.DS2 loadings.DS1 loadings.DS2 Cultivar i_group ## 1 -0.66902049 1.2508355 -1.80452082 -0.8166182 AC Belmont 3 ## 2 -0.55105954 0.8275579 0.33929124 1.1542930 AC Belmont 3 ## 3 -0.40168546 0.9054121 -1.96450084 2.3374270 AC Belmont 3 ## 4 -0.30280178 0.9424118 2.28179831 0.8360123 AC Belmont 3 ## 5 0.10410599 1.0195041 -0.04728401 1.8852473 AC Belmont 3 ## 6 -0.02339004 0.9371925 1.19521611 -5.3963614 AC Belmont 3 centroids = lda_centroids[lda_centroids$group %in% filter_cultivars, ] names(centroids)[match(&quot;group&quot;, names(centroids))] &lt;- &quot;Cultivar&quot; centroids &lt;- centroids %&gt;% left_join(cultivars_filtre, by=&quot;Cultivar&quot;) centroids %&gt;% head() ## # A tibble: 6 x 4 ## Cultivar DS1 DS2 i_group ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 AC Belmont 0.0326 0.787 3 ## 2 AC Chaleur 0.755 0.257 2 ## 3 Amandine 0.636 0.989 1 ## 4 Andover -1.90 0.138 4 ## 5 Aquilon -0.140 0.302 4 ## 6 Argos -0.119 0.677 3 Plot with ggplot2 #png(&quot;data/clustering.png&quot;, width=3000, height=1400, res = 300) options(repr.plot.width = 9, repr.plot.height = 9) g &lt;- ggplot(centroids, aes(DS1, DS2, label = Cultivar, col=i_group)) + geom_text_repel() + geom_point(alpha = 0.5) + theme_classic(base_size = 12) + scale_color_manual(values=c(&quot;red&quot;, &quot;magenta&quot;, &quot;blue&quot;, &quot;black&quot;)) + theme(axis.text=element_text(size=12)) + theme(text=element_text(family=&quot;Arial&quot;, face=&quot;bold&quot;, size=12)) # Add discriminant loadings using geom_segment and arrow x=0; y=0; labels = c(clr_no, rep(NA, nrow(df)-length(clr_no))) g + geom_segment(data=df, mapping=aes(x=x, y=y, xend=x+loadings.DS1, yend=y+loadings.DS2), arrow=arrow(), size = 1, color=&quot;grey80&quot;) + geom_text(data=df, mapping=aes(x=loadings.DS1, y=loadings.DS2, label=labels), size=5, color=&quot;black&quot;) + geom_hline(yintercept=0, color=&quot;black&quot;, linetype=2) + geom_vline(mapping=aes(xintercept=0), color=&quot;black&quot;, linetype=2) + theme(axis.line=element_blank()) Figure 2.4: Discriminant biplot and cluster analysis result of potato cultivars. #ggsave(&quot;images/cultivar_clust.png&quot;, width=10, height=8, dpi = 300) Push Cultivars yield cut-off and ionomics groups in the data frame. ionomicGroup &lt;- data.frame(lda_centroids[, 1], ionomicGroup = factor(highYieldersKmeans$partition[, &quot;4 groups&quot;])) colnames(ionomicGroup)[colnames(ionomicGroup)==&quot;group&quot;] &lt;- &quot;Cultivar&quot; cutQ &lt;- cutQ[-1, ] # to discard missing cultivars colnames(cutQ)[which(names(cutQ) == &quot;rv_cut&quot;)] &lt;- &quot;yieldCutoff&quot; cutQ_ig &lt;- cutQ %&gt;% left_join(ionomicGroup, by = &quot;Cultivar&quot;) fol_df &lt;- fol_df %&gt;% left_join(y = cutQ_ig, by = &#39;Cultivar&#39;) %&gt;% select(-rv_cut) Processing data for Machine Learning dfml, saved as data_ionome.csv. Exctract usefull columns from fol_df. Conserve only `complete cases. dfml &lt;- fol_df %&gt;% mutate(isNA = apply(.[c(clr_no, cult_yield)], 1, anyNA)) %&gt;% mutate(is10pcf = AnalyseFoliaireStade == &quot;10% fleur&quot;) %&gt;% filter(!isNA &amp; is10pcf &amp; NoEssai != &quot;2&quot;) %&gt;% select(one_of(c(keys_col, clr_no, cult_yield, &#39;yieldClass&#39;, &#39;ionomicGroup&#39;))) %&gt;% select(-AnalyseFoliaireStade) %&gt;% droplevels() %&gt;% filter(complete.cases(.)) nrow(dfml) ## [1] 3369 Backup write.csv2(dfml, &quot;data/data_ionome.csv&quot;) Linear mixed effect modeling of yield relative to the ionome*ionomicGroup interaction (extraction of the interactions coefficients). library(&quot;nlme&quot;) source(&quot;data/functions.R&quot;) # contains a costum r-square function dfml$Cultivar &lt;- factor(dfml$Cultivar) dfml$Maturity5 &lt;- relevel(dfml$Maturity5, ref=&quot;late&quot;) dfml$Cultivar &lt;- relevel(dfml$Cultivar, ref=&quot;Goldrush&quot;) dfml$NoEssai &lt;- factor(dfml$NoEssai) colnames(dfml)[colnames(dfml)==&quot;ionomicGroup&quot;] &lt;- &quot;group_i&quot; dfml$group_i &lt;- factor(dfml$group_i) clr_no &lt;- c(&quot;clr_N&quot;, &quot;clr_P&quot;, &quot;clr_K&quot;, &quot;clr_Ca&quot;, &quot;clr_Mg&quot;, &quot;clr_Fv&quot;) clrNo &lt;- c(&quot;clrN&quot;, &quot;clrP&quot;, &quot;clrK&quot;, &quot;clrCa&quot;, &quot;clrMg&quot;, &quot;clrFv&quot;) # for plot colnames(dfml)[which(names(dfml) %in% clr_no)] &lt;- clrNo Scale clr coordinates dfml.sc &lt;- dfml # copy dfml.sc[, clrNo] &lt;- apply(dfml.sc[, clrNo], 2, scale) Fit linear mixed model. Discard the filling value to deal with singularity problem. used_clr = c(&quot;clrN&quot;, &quot;clrP&quot;, &quot;clrK&quot;, &quot;clrCa&quot;, &quot;clrMg&quot;) # without &quot;clr_Fv&quot; lmm &lt;- lme(RendVendable ~ (clrN + clrP + clrK + clrCa + clrMg):group_i, data=dfml.sc, random= ~1|NoEssai) pseudoR2 = rsq(dfml.sc$RendVendable, predict(lmm)) pseudoR2 ## [1] 0.7400044 Extract the interactions coefficients and their p-values (pv) matrix: pv &lt;- summary(lmm)$tTable[-1,] pv ## Value Std.Error DF t-value p-value ## clrN:group_i1 6.645143 2.1649322 3150 3.069446 2.162828e-03 ## clrN:group_i2 9.007241 0.6874520 3150 13.102357 3.132439e-38 ## clrN:group_i3 6.949603 1.4852004 3150 4.679236 3.000809e-06 ## clrN:group_i4 3.195431 0.3866881 3150 8.263587 2.057744e-16 ## clrP:group_i1 6.795965 2.7092875 3150 2.508396 1.217794e-02 ## clrP:group_i2 8.449904 0.8658023 3150 9.759623 3.449225e-22 ## clrP:group_i3 9.003016 2.2037071 3150 4.085396 4.509847e-05 ## clrP:group_i4 1.618988 0.4610944 3150 3.511187 4.523723e-04 ## clrK:group_i1 7.646919 2.8537539 3150 2.679600 7.409365e-03 ## clrK:group_i2 9.272317 0.9305423 3150 9.964423 4.767161e-23 ## clrK:group_i3 3.434110 2.7288719 3150 1.258436 2.083275e-01 ## clrK:group_i4 1.740554 0.6261693 3150 2.779686 5.473444e-03 ## clrCa:group_i1 7.936266 2.4551030 3150 3.232559 1.239518e-03 ## clrCa:group_i2 9.912541 0.9136017 3150 10.849958 5.942979e-27 ## clrCa:group_i3 7.201106 1.9860081 3150 3.625920 2.924953e-04 ## clrCa:group_i4 3.230313 0.5834249 3150 5.536811 3.333127e-08 ## clrMg:group_i1 7.332749 2.7405918 3150 2.675608 7.497989e-03 ## clrMg:group_i2 7.389987 0.8650038 3150 8.543300 2.000749e-17 ## clrMg:group_i3 4.020082 2.1795290 3150 1.844473 6.520812e-02 ## clrMg:group_i4 1.114686 0.4414678 3150 2.524955 1.162000e-02 Also extract their confident intervals, and process data for the plot. interval &lt;- tibble(Estimate = intervals(lmm)$fixed[-1, 2], LL = intervals(lmm)$fixed[-1, 1], UL = intervals(lmm)$fixed[-1, 3]) interval$variable &lt;- rep(&#39;NA&#39;, nrow(interval)) interval$variable &lt;- rownames(intervals(lmm)$fixed)[-1] interval$ionomic_group &lt;- rep(paste(&quot;group&quot;, 1:nlevels(dfml$group_i)), length(clrNo)-1) interval$used_clr &lt;- rep(used_clr, each = nlevels(dfml$group_i)) interval$pvalue &lt;- pv[,&quot;p-value&quot;] interval$is_significant = ifelse(interval$pvalue &lt;= 0.05, &#39;P &lt; 0.05&#39;, &#39;P &gt; 0.05&#39;) interval ## # A tibble: 20 x 8 ## Estimate LL UL variable ionomic_group used_clr pvalue ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 6.65 2.40 10.9 clrN:gr~ group 1 clrN 2.16e- 3 ## 2 9.01 7.66 10.4 clrN:gr~ group 2 clrN 3.13e-38 ## 3 6.95 4.04 9.86 clrN:gr~ group 3 clrN 3.00e- 6 ## 4 3.20 2.44 3.95 clrN:gr~ group 4 clrN 2.06e-16 ## 5 6.80 1.48 12.1 clrP:gr~ group 1 clrP 1.22e- 2 ## 6 8.45 6.75 10.1 clrP:gr~ group 2 clrP 3.45e-22 ## 7 9.00 4.68 13.3 clrP:gr~ group 3 clrP 4.51e- 5 ## 8 1.62 0.715 2.52 clrP:gr~ group 4 clrP 4.52e- 4 ## 9 7.65 2.05 13.2 clrK:gr~ group 1 clrK 7.41e- 3 ## 10 9.27 7.45 11.1 clrK:gr~ group 2 clrK 4.77e-23 ## 11 3.43 -1.92 8.78 clrK:gr~ group 3 clrK 2.08e- 1 ## 12 1.74 0.513 2.97 clrK:gr~ group 4 clrK 5.47e- 3 ## 13 7.94 3.12 12.8 clrCa:g~ group 1 clrCa 1.24e- 3 ## 14 9.91 8.12 11.7 clrCa:g~ group 2 clrCa 5.94e-27 ## 15 7.20 3.31 11.1 clrCa:g~ group 3 clrCa 2.92e- 4 ## 16 3.23 2.09 4.37 clrCa:g~ group 4 clrCa 3.33e- 8 ## 17 7.33 1.96 12.7 clrMg:g~ group 1 clrMg 7.50e- 3 ## 18 7.39 5.69 9.09 clrMg:g~ group 2 clrMg 2.00e-17 ## 19 4.02 -0.253 8.29 clrMg:g~ group 3 clrMg 6.52e- 2 ## 20 1.11 0.249 1.98 clrMg:g~ group 4 clrMg 1.16e- 2 ## # ... with 1 more variable: is_significant &lt;chr&gt; Plot with ggplot2. options(repr.plot.width = 5, repr.plot.height = 5) gg &lt;- ggplot(data = interval, mapping = aes(x = Estimate, y = used_clr, color=is_significant)) + facet_grid(ionomic_group ~ .) + #, scales = &#39;free&#39;, space = &#39;free&#39;) + geom_vline(xintercept = 0, lty = 2) + geom_segment(mapping = aes(x = LL, xend = UL, y = used_clr, yend = used_clr)) + geom_point() + #scale_color_grey(start=.1, end=0) + labs(x = &quot;Coefficient&quot;, y = &quot;&quot;) + theme_bw() + theme(text=element_text(family=&quot;Arial&quot;, face=&quot;bold&quot;, size=12)) gg + theme(legend.title = element_blank())#, legend.position = &#39;bottom&#39;) Figure 2.5: Effect of ionome perturbation on marketable yield as illustrated by a linear mixed effect model. #ggsave(&quot;images/coef_lmm.tiff&quot;, width = 5, height = 5, dpi = 300) "]
]
